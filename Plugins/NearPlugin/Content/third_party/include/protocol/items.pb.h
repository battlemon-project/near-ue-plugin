// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: items.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_items_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_items_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021005 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "common.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_items_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_items_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_items_2eproto;
namespace game {
namespace battlemon {
namespace items {
class AttachBundleRequest;
struct AttachBundleRequestDefaultTypeInternal;
extern AttachBundleRequestDefaultTypeInternal _AttachBundleRequest_default_instance_;
class DetachBundleRequest;
struct DetachBundleRequestDefaultTypeInternal;
extern DetachBundleRequestDefaultTypeInternal _DetachBundleRequest_default_instance_;
class EditBundleRequest;
struct EditBundleRequestDefaultTypeInternal;
extern EditBundleRequestDefaultTypeInternal _EditBundleRequest_default_instance_;
class GetBundlesRequest;
struct GetBundlesRequestDefaultTypeInternal;
extern GetBundlesRequestDefaultTypeInternal _GetBundlesRequest_default_instance_;
class GetBundlesResponse;
struct GetBundlesResponseDefaultTypeInternal;
extern GetBundlesResponseDefaultTypeInternal _GetBundlesResponse_default_instance_;
class Item;
struct ItemDefaultTypeInternal;
extern ItemDefaultTypeInternal _Item_default_instance_;
class ItemsRequest;
struct ItemsRequestDefaultTypeInternal;
extern ItemsRequestDefaultTypeInternal _ItemsRequest_default_instance_;
class ItemsResponse;
struct ItemsResponseDefaultTypeInternal;
extern ItemsResponseDefaultTypeInternal _ItemsResponse_default_instance_;
class NftItem;
struct NftItemDefaultTypeInternal;
extern NftItemDefaultTypeInternal _NftItem_default_instance_;
class NonNftItem;
struct NonNftItemDefaultTypeInternal;
extern NonNftItemDefaultTypeInternal _NonNftItem_default_instance_;
class Trait;
struct TraitDefaultTypeInternal;
extern TraitDefaultTypeInternal _Trait_default_instance_;
class WeaponBundle;
struct WeaponBundleDefaultTypeInternal;
extern WeaponBundleDefaultTypeInternal _WeaponBundle_default_instance_;
class WeaponBundleItem;
struct WeaponBundleItemDefaultTypeInternal;
extern WeaponBundleItemDefaultTypeInternal _WeaponBundleItem_default_instance_;
}  // namespace items
}  // namespace battlemon
}  // namespace game
PROTOBUF_NAMESPACE_OPEN
template<> ::game::battlemon::items::AttachBundleRequest* Arena::CreateMaybeMessage<::game::battlemon::items::AttachBundleRequest>(Arena*);
template<> ::game::battlemon::items::DetachBundleRequest* Arena::CreateMaybeMessage<::game::battlemon::items::DetachBundleRequest>(Arena*);
template<> ::game::battlemon::items::EditBundleRequest* Arena::CreateMaybeMessage<::game::battlemon::items::EditBundleRequest>(Arena*);
template<> ::game::battlemon::items::GetBundlesRequest* Arena::CreateMaybeMessage<::game::battlemon::items::GetBundlesRequest>(Arena*);
template<> ::game::battlemon::items::GetBundlesResponse* Arena::CreateMaybeMessage<::game::battlemon::items::GetBundlesResponse>(Arena*);
template<> ::game::battlemon::items::Item* Arena::CreateMaybeMessage<::game::battlemon::items::Item>(Arena*);
template<> ::game::battlemon::items::ItemsRequest* Arena::CreateMaybeMessage<::game::battlemon::items::ItemsRequest>(Arena*);
template<> ::game::battlemon::items::ItemsResponse* Arena::CreateMaybeMessage<::game::battlemon::items::ItemsResponse>(Arena*);
template<> ::game::battlemon::items::NftItem* Arena::CreateMaybeMessage<::game::battlemon::items::NftItem>(Arena*);
template<> ::game::battlemon::items::NonNftItem* Arena::CreateMaybeMessage<::game::battlemon::items::NonNftItem>(Arena*);
template<> ::game::battlemon::items::Trait* Arena::CreateMaybeMessage<::game::battlemon::items::Trait>(Arena*);
template<> ::game::battlemon::items::WeaponBundle* Arena::CreateMaybeMessage<::game::battlemon::items::WeaponBundle>(Arena*);
template<> ::game::battlemon::items::WeaponBundleItem* Arena::CreateMaybeMessage<::game::battlemon::items::WeaponBundleItem>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace game {
namespace battlemon {
namespace items {

enum WeaponBundleItemType : int {
  BUNDLE_ITEM_PRIMARY = 0,
  BUNDLE_ITEM_SECONDARY = 1,
  BUNDLE_ITEM_MELEE = 2,
  BUNDLE_ITEM_TACTICAL = 3,
  BUNDLE_ITEM_MILITARY = 4,
  BUNDLE_ITEM_PERK = 5,
  WeaponBundleItemType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  WeaponBundleItemType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool WeaponBundleItemType_IsValid(int value);
constexpr WeaponBundleItemType WeaponBundleItemType_MIN = BUNDLE_ITEM_PRIMARY;
constexpr WeaponBundleItemType WeaponBundleItemType_MAX = BUNDLE_ITEM_PERK;
constexpr int WeaponBundleItemType_ARRAYSIZE = WeaponBundleItemType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* WeaponBundleItemType_descriptor();
template<typename T>
inline const std::string& WeaponBundleItemType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, WeaponBundleItemType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function WeaponBundleItemType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    WeaponBundleItemType_descriptor(), enum_t_value);
}
inline bool WeaponBundleItemType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, WeaponBundleItemType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<WeaponBundleItemType>(
    WeaponBundleItemType_descriptor(), name, value);
}
enum WeaponBundleSlotType : int {
  BUNDLE_SLOT_PRIMARY = 0,
  BUNDLE_SLOT_SECONDARY = 1,
  BUNDLE_SLOT_MELEE = 2,
  BUNDLE_SLOT_TACTICAL_ONE = 3,
  BUNDLE_SLOT_TACTICAL_TWO = 4,
  BUNDLE_SLOT_MILITARY_ONE = 5,
  BUNDLE_SLOT_MILITARY_TWO = 6,
  BUNDLE_SLOT_PERK_ONE = 7,
  BUNDLE_SLOT_PERK_TWO = 8,
  WeaponBundleSlotType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  WeaponBundleSlotType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool WeaponBundleSlotType_IsValid(int value);
constexpr WeaponBundleSlotType WeaponBundleSlotType_MIN = BUNDLE_SLOT_PRIMARY;
constexpr WeaponBundleSlotType WeaponBundleSlotType_MAX = BUNDLE_SLOT_PERK_TWO;
constexpr int WeaponBundleSlotType_ARRAYSIZE = WeaponBundleSlotType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* WeaponBundleSlotType_descriptor();
template<typename T>
inline const std::string& WeaponBundleSlotType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, WeaponBundleSlotType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function WeaponBundleSlotType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    WeaponBundleSlotType_descriptor(), enum_t_value);
}
inline bool WeaponBundleSlotType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, WeaponBundleSlotType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<WeaponBundleSlotType>(
    WeaponBundleSlotType_descriptor(), name, value);
}
// ===================================================================

class ItemsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:game.battlemon.items.ItemsRequest) */ {
 public:
  inline ItemsRequest() : ItemsRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR ItemsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ItemsRequest(const ItemsRequest& from);
  ItemsRequest(ItemsRequest&& from) noexcept
    : ItemsRequest() {
    *this = ::std::move(from);
  }

  inline ItemsRequest& operator=(const ItemsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ItemsRequest& operator=(ItemsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ItemsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ItemsRequest* internal_default_instance() {
    return reinterpret_cast<const ItemsRequest*>(
               &_ItemsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(ItemsRequest& a, ItemsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ItemsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ItemsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ItemsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ItemsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ItemsRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ItemsRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "game.battlemon.items.ItemsRequest";
  }
  protected:
  explicit ItemsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:game.battlemon.items.ItemsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_items_2eproto;
};
// -------------------------------------------------------------------

class ItemsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:game.battlemon.items.ItemsResponse) */ {
 public:
  inline ItemsResponse() : ItemsResponse(nullptr) {}
  ~ItemsResponse() override;
  explicit PROTOBUF_CONSTEXPR ItemsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ItemsResponse(const ItemsResponse& from);
  ItemsResponse(ItemsResponse&& from) noexcept
    : ItemsResponse() {
    *this = ::std::move(from);
  }

  inline ItemsResponse& operator=(const ItemsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ItemsResponse& operator=(ItemsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ItemsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ItemsResponse* internal_default_instance() {
    return reinterpret_cast<const ItemsResponse*>(
               &_ItemsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ItemsResponse& a, ItemsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ItemsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ItemsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ItemsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ItemsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ItemsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ItemsResponse& from) {
    ItemsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ItemsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "game.battlemon.items.ItemsResponse";
  }
  protected:
  explicit ItemsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 1,
  };
  // repeated .game.battlemon.items.Item items = 1;
  int items_size() const;
  private:
  int _internal_items_size() const;
  public:
  void clear_items();
  ::game::battlemon::items::Item* mutable_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::game::battlemon::items::Item >*
      mutable_items();
  private:
  const ::game::battlemon::items::Item& _internal_items(int index) const;
  ::game::battlemon::items::Item* _internal_add_items();
  public:
  const ::game::battlemon::items::Item& items(int index) const;
  ::game::battlemon::items::Item* add_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::game::battlemon::items::Item >&
      items() const;

  // @@protoc_insertion_point(class_scope:game.battlemon.items.ItemsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::game::battlemon::items::Item > items_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_items_2eproto;
};
// -------------------------------------------------------------------

class Item final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:game.battlemon.items.Item) */ {
 public:
  inline Item() : Item(nullptr) {}
  ~Item() override;
  explicit PROTOBUF_CONSTEXPR Item(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Item(const Item& from);
  Item(Item&& from) noexcept
    : Item() {
    *this = ::std::move(from);
  }

  inline Item& operator=(const Item& from) {
    CopyFrom(from);
    return *this;
  }
  inline Item& operator=(Item&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Item& default_instance() {
    return *internal_default_instance();
  }
  enum ItemCase {
    kNft = 1,
    kNonNft = 2,
    ITEM_NOT_SET = 0,
  };

  static inline const Item* internal_default_instance() {
    return reinterpret_cast<const Item*>(
               &_Item_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Item& a, Item& b) {
    a.Swap(&b);
  }
  inline void Swap(Item* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Item* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Item* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Item>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Item& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Item& from) {
    Item::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Item* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "game.battlemon.items.Item";
  }
  protected:
  explicit Item(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNftFieldNumber = 1,
    kNonNftFieldNumber = 2,
  };
  // .game.battlemon.items.NftItem nft = 1;
  bool has_nft() const;
  private:
  bool _internal_has_nft() const;
  public:
  void clear_nft();
  const ::game::battlemon::items::NftItem& nft() const;
  PROTOBUF_NODISCARD ::game::battlemon::items::NftItem* release_nft();
  ::game::battlemon::items::NftItem* mutable_nft();
  void set_allocated_nft(::game::battlemon::items::NftItem* nft);
  private:
  const ::game::battlemon::items::NftItem& _internal_nft() const;
  ::game::battlemon::items::NftItem* _internal_mutable_nft();
  public:
  void unsafe_arena_set_allocated_nft(
      ::game::battlemon::items::NftItem* nft);
  ::game::battlemon::items::NftItem* unsafe_arena_release_nft();

  // .game.battlemon.items.NonNftItem non_nft = 2;
  bool has_non_nft() const;
  private:
  bool _internal_has_non_nft() const;
  public:
  void clear_non_nft();
  const ::game::battlemon::items::NonNftItem& non_nft() const;
  PROTOBUF_NODISCARD ::game::battlemon::items::NonNftItem* release_non_nft();
  ::game::battlemon::items::NonNftItem* mutable_non_nft();
  void set_allocated_non_nft(::game::battlemon::items::NonNftItem* non_nft);
  private:
  const ::game::battlemon::items::NonNftItem& _internal_non_nft() const;
  ::game::battlemon::items::NonNftItem* _internal_mutable_non_nft();
  public:
  void unsafe_arena_set_allocated_non_nft(
      ::game::battlemon::items::NonNftItem* non_nft);
  ::game::battlemon::items::NonNftItem* unsafe_arena_release_non_nft();

  void clear_item();
  ItemCase item_case() const;
  // @@protoc_insertion_point(class_scope:game.battlemon.items.Item)
 private:
  class _Internal;
  void set_has_nft();
  void set_has_non_nft();

  inline bool has_item() const;
  inline void clear_has_item();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union ItemUnion {
      constexpr ItemUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::game::battlemon::items::NftItem* nft_;
      ::game::battlemon::items::NonNftItem* non_nft_;
    } item_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_items_2eproto;
};
// -------------------------------------------------------------------

class NftItem final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:game.battlemon.items.NftItem) */ {
 public:
  inline NftItem() : NftItem(nullptr) {}
  ~NftItem() override;
  explicit PROTOBUF_CONSTEXPR NftItem(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NftItem(const NftItem& from);
  NftItem(NftItem&& from) noexcept
    : NftItem() {
    *this = ::std::move(from);
  }

  inline NftItem& operator=(const NftItem& from) {
    CopyFrom(from);
    return *this;
  }
  inline NftItem& operator=(NftItem&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NftItem& default_instance() {
    return *internal_default_instance();
  }
  static inline const NftItem* internal_default_instance() {
    return reinterpret_cast<const NftItem*>(
               &_NftItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(NftItem& a, NftItem& b) {
    a.Swap(&b);
  }
  inline void Swap(NftItem* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NftItem* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NftItem* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NftItem>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NftItem& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NftItem& from) {
    NftItem::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NftItem* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "game.battlemon.items.NftItem";
  }
  protected:
  explicit NftItem(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTraitsFieldNumber = 5,
    kAttachedBundlesFieldNumber = 7,
    kIdFieldNumber = 1,
    kTypeFieldNumber = 2,
    kOwnerFieldNumber = 3,
    kUrlFieldNumber = 4,
    kCreatedAtFieldNumber = 6,
  };
  // repeated .game.battlemon.items.Trait traits = 5;
  int traits_size() const;
  private:
  int _internal_traits_size() const;
  public:
  void clear_traits();
  ::game::battlemon::items::Trait* mutable_traits(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::game::battlemon::items::Trait >*
      mutable_traits();
  private:
  const ::game::battlemon::items::Trait& _internal_traits(int index) const;
  ::game::battlemon::items::Trait* _internal_add_traits();
  public:
  const ::game::battlemon::items::Trait& traits(int index) const;
  ::game::battlemon::items::Trait* add_traits();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::game::battlemon::items::Trait >&
      traits() const;

  // repeated .game.battlemon.items.WeaponBundle attached_bundles = 7;
  int attached_bundles_size() const;
  private:
  int _internal_attached_bundles_size() const;
  public:
  void clear_attached_bundles();
  ::game::battlemon::items::WeaponBundle* mutable_attached_bundles(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::game::battlemon::items::WeaponBundle >*
      mutable_attached_bundles();
  private:
  const ::game::battlemon::items::WeaponBundle& _internal_attached_bundles(int index) const;
  ::game::battlemon::items::WeaponBundle* _internal_add_attached_bundles();
  public:
  const ::game::battlemon::items::WeaponBundle& attached_bundles(int index) const;
  ::game::battlemon::items::WeaponBundle* add_attached_bundles();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::game::battlemon::items::WeaponBundle >&
      attached_bundles() const;

  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string type = 2;
  void clear_type();
  const std::string& type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // string owner = 3;
  void clear_owner();
  const std::string& owner() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_owner(ArgT0&& arg0, ArgT... args);
  std::string* mutable_owner();
  PROTOBUF_NODISCARD std::string* release_owner();
  void set_allocated_owner(std::string* owner);
  private:
  const std::string& _internal_owner() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_owner(const std::string& value);
  std::string* _internal_mutable_owner();
  public:

  // string url = 4;
  void clear_url();
  const std::string& url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_url();
  PROTOBUF_NODISCARD std::string* release_url();
  void set_allocated_url(std::string* url);
  private:
  const std::string& _internal_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_url(const std::string& value);
  std::string* _internal_mutable_url();
  public:

  // int64 created_at = 6;
  void clear_created_at();
  int64_t created_at() const;
  void set_created_at(int64_t value);
  private:
  int64_t _internal_created_at() const;
  void _internal_set_created_at(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:game.battlemon.items.NftItem)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::game::battlemon::items::Trait > traits_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::game::battlemon::items::WeaponBundle > attached_bundles_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr owner_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr url_;
    int64_t created_at_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_items_2eproto;
};
// -------------------------------------------------------------------

class Trait final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:game.battlemon.items.Trait) */ {
 public:
  inline Trait() : Trait(nullptr) {}
  ~Trait() override;
  explicit PROTOBUF_CONSTEXPR Trait(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Trait(const Trait& from);
  Trait(Trait&& from) noexcept
    : Trait() {
    *this = ::std::move(from);
  }

  inline Trait& operator=(const Trait& from) {
    CopyFrom(from);
    return *this;
  }
  inline Trait& operator=(Trait&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Trait& default_instance() {
    return *internal_default_instance();
  }
  static inline const Trait* internal_default_instance() {
    return reinterpret_cast<const Trait*>(
               &_Trait_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Trait& a, Trait& b) {
    a.Swap(&b);
  }
  inline void Swap(Trait* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Trait* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Trait* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Trait>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Trait& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Trait& from) {
    Trait::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Trait* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "game.battlemon.items.Trait";
  }
  protected:
  explicit Trait(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kFlavourFieldNumber = 2,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string flavour = 2;
  void clear_flavour();
  const std::string& flavour() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_flavour(ArgT0&& arg0, ArgT... args);
  std::string* mutable_flavour();
  PROTOBUF_NODISCARD std::string* release_flavour();
  void set_allocated_flavour(std::string* flavour);
  private:
  const std::string& _internal_flavour() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_flavour(const std::string& value);
  std::string* _internal_mutable_flavour();
  public:

  // @@protoc_insertion_point(class_scope:game.battlemon.items.Trait)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr flavour_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_items_2eproto;
};
// -------------------------------------------------------------------

class NonNftItem final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:game.battlemon.items.NonNftItem) */ {
 public:
  inline NonNftItem() : NonNftItem(nullptr) {}
  ~NonNftItem() override;
  explicit PROTOBUF_CONSTEXPR NonNftItem(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NonNftItem(const NonNftItem& from);
  NonNftItem(NonNftItem&& from) noexcept
    : NonNftItem() {
    *this = ::std::move(from);
  }

  inline NonNftItem& operator=(const NonNftItem& from) {
    CopyFrom(from);
    return *this;
  }
  inline NonNftItem& operator=(NonNftItem&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NonNftItem& default_instance() {
    return *internal_default_instance();
  }
  static inline const NonNftItem* internal_default_instance() {
    return reinterpret_cast<const NonNftItem*>(
               &_NonNftItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(NonNftItem& a, NonNftItem& b) {
    a.Swap(&b);
  }
  inline void Swap(NonNftItem* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NonNftItem* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NonNftItem* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NonNftItem>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NonNftItem& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NonNftItem& from) {
    NonNftItem::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NonNftItem* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "game.battlemon.items.NonNftItem";
  }
  protected:
  explicit NonNftItem(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAttachedBundlesFieldNumber = 4,
    kIdFieldNumber = 1,
    kOwnerFieldNumber = 2,
    kLevelFieldNumber = 3,
  };
  // repeated .game.battlemon.items.WeaponBundle attached_bundles = 4;
  int attached_bundles_size() const;
  private:
  int _internal_attached_bundles_size() const;
  public:
  void clear_attached_bundles();
  ::game::battlemon::items::WeaponBundle* mutable_attached_bundles(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::game::battlemon::items::WeaponBundle >*
      mutable_attached_bundles();
  private:
  const ::game::battlemon::items::WeaponBundle& _internal_attached_bundles(int index) const;
  ::game::battlemon::items::WeaponBundle* _internal_add_attached_bundles();
  public:
  const ::game::battlemon::items::WeaponBundle& attached_bundles(int index) const;
  ::game::battlemon::items::WeaponBundle* add_attached_bundles();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::game::battlemon::items::WeaponBundle >&
      attached_bundles() const;

  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string owner = 2;
  void clear_owner();
  const std::string& owner() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_owner(ArgT0&& arg0, ArgT... args);
  std::string* mutable_owner();
  PROTOBUF_NODISCARD std::string* release_owner();
  void set_allocated_owner(std::string* owner);
  private:
  const std::string& _internal_owner() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_owner(const std::string& value);
  std::string* _internal_mutable_owner();
  public:

  // int32 level = 3;
  void clear_level();
  int32_t level() const;
  void set_level(int32_t value);
  private:
  int32_t _internal_level() const;
  void _internal_set_level(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:game.battlemon.items.NonNftItem)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::game::battlemon::items::WeaponBundle > attached_bundles_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr owner_;
    int32_t level_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_items_2eproto;
};
// -------------------------------------------------------------------

class WeaponBundle final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:game.battlemon.items.WeaponBundle) */ {
 public:
  inline WeaponBundle() : WeaponBundle(nullptr) {}
  ~WeaponBundle() override;
  explicit PROTOBUF_CONSTEXPR WeaponBundle(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WeaponBundle(const WeaponBundle& from);
  WeaponBundle(WeaponBundle&& from) noexcept
    : WeaponBundle() {
    *this = ::std::move(from);
  }

  inline WeaponBundle& operator=(const WeaponBundle& from) {
    CopyFrom(from);
    return *this;
  }
  inline WeaponBundle& operator=(WeaponBundle&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WeaponBundle& default_instance() {
    return *internal_default_instance();
  }
  static inline const WeaponBundle* internal_default_instance() {
    return reinterpret_cast<const WeaponBundle*>(
               &_WeaponBundle_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(WeaponBundle& a, WeaponBundle& b) {
    a.Swap(&b);
  }
  inline void Swap(WeaponBundle* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WeaponBundle* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WeaponBundle* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WeaponBundle>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WeaponBundle& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const WeaponBundle& from) {
    WeaponBundle::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WeaponBundle* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "game.battlemon.items.WeaponBundle";
  }
  protected:
  explicit WeaponBundle(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 2,
    kTitleFieldNumber = 3,
    kBundleNumFieldNumber = 1,
    kLevelFieldNumber = 4,
  };
  // repeated .game.battlemon.items.WeaponBundleItem items = 2;
  int items_size() const;
  private:
  int _internal_items_size() const;
  public:
  void clear_items();
  ::game::battlemon::items::WeaponBundleItem* mutable_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::game::battlemon::items::WeaponBundleItem >*
      mutable_items();
  private:
  const ::game::battlemon::items::WeaponBundleItem& _internal_items(int index) const;
  ::game::battlemon::items::WeaponBundleItem* _internal_add_items();
  public:
  const ::game::battlemon::items::WeaponBundleItem& items(int index) const;
  ::game::battlemon::items::WeaponBundleItem* add_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::game::battlemon::items::WeaponBundleItem >&
      items() const;

  // string title = 3;
  void clear_title();
  const std::string& title() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_title(ArgT0&& arg0, ArgT... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* title);
  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(const std::string& value);
  std::string* _internal_mutable_title();
  public:

  // int32 bundle_num = 1;
  void clear_bundle_num();
  int32_t bundle_num() const;
  void set_bundle_num(int32_t value);
  private:
  int32_t _internal_bundle_num() const;
  void _internal_set_bundle_num(int32_t value);
  public:

  // int32 level = 4;
  void clear_level();
  int32_t level() const;
  void set_level(int32_t value);
  private:
  int32_t _internal_level() const;
  void _internal_set_level(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:game.battlemon.items.WeaponBundle)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::game::battlemon::items::WeaponBundleItem > items_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
    int32_t bundle_num_;
    int32_t level_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_items_2eproto;
};
// -------------------------------------------------------------------

class WeaponBundleItem final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:game.battlemon.items.WeaponBundleItem) */ {
 public:
  inline WeaponBundleItem() : WeaponBundleItem(nullptr) {}
  ~WeaponBundleItem() override;
  explicit PROTOBUF_CONSTEXPR WeaponBundleItem(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WeaponBundleItem(const WeaponBundleItem& from);
  WeaponBundleItem(WeaponBundleItem&& from) noexcept
    : WeaponBundleItem() {
    *this = ::std::move(from);
  }

  inline WeaponBundleItem& operator=(const WeaponBundleItem& from) {
    CopyFrom(from);
    return *this;
  }
  inline WeaponBundleItem& operator=(WeaponBundleItem&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WeaponBundleItem& default_instance() {
    return *internal_default_instance();
  }
  static inline const WeaponBundleItem* internal_default_instance() {
    return reinterpret_cast<const WeaponBundleItem*>(
               &_WeaponBundleItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(WeaponBundleItem& a, WeaponBundleItem& b) {
    a.Swap(&b);
  }
  inline void Swap(WeaponBundleItem* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WeaponBundleItem* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WeaponBundleItem* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WeaponBundleItem>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WeaponBundleItem& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const WeaponBundleItem& from) {
    WeaponBundleItem::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WeaponBundleItem* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "game.battlemon.items.WeaponBundleItem";
  }
  protected:
  explicit WeaponBundleItem(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSkinFieldNumber = 2,
    kItemTypeFieldNumber = 1,
    kSlotTypeFieldNumber = 3,
  };
  // string skin = 2;
  void clear_skin();
  const std::string& skin() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_skin(ArgT0&& arg0, ArgT... args);
  std::string* mutable_skin();
  PROTOBUF_NODISCARD std::string* release_skin();
  void set_allocated_skin(std::string* skin);
  private:
  const std::string& _internal_skin() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_skin(const std::string& value);
  std::string* _internal_mutable_skin();
  public:

  // .game.battlemon.items.WeaponBundleItemType item_type = 1;
  void clear_item_type();
  ::game::battlemon::items::WeaponBundleItemType item_type() const;
  void set_item_type(::game::battlemon::items::WeaponBundleItemType value);
  private:
  ::game::battlemon::items::WeaponBundleItemType _internal_item_type() const;
  void _internal_set_item_type(::game::battlemon::items::WeaponBundleItemType value);
  public:

  // .game.battlemon.items.WeaponBundleSlotType slot_type = 3;
  void clear_slot_type();
  ::game::battlemon::items::WeaponBundleSlotType slot_type() const;
  void set_slot_type(::game::battlemon::items::WeaponBundleSlotType value);
  private:
  ::game::battlemon::items::WeaponBundleSlotType _internal_slot_type() const;
  void _internal_set_slot_type(::game::battlemon::items::WeaponBundleSlotType value);
  public:

  // @@protoc_insertion_point(class_scope:game.battlemon.items.WeaponBundleItem)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr skin_;
    int item_type_;
    int slot_type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_items_2eproto;
};
// -------------------------------------------------------------------

class GetBundlesRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:game.battlemon.items.GetBundlesRequest) */ {
 public:
  inline GetBundlesRequest() : GetBundlesRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR GetBundlesRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetBundlesRequest(const GetBundlesRequest& from);
  GetBundlesRequest(GetBundlesRequest&& from) noexcept
    : GetBundlesRequest() {
    *this = ::std::move(from);
  }

  inline GetBundlesRequest& operator=(const GetBundlesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetBundlesRequest& operator=(GetBundlesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetBundlesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetBundlesRequest* internal_default_instance() {
    return reinterpret_cast<const GetBundlesRequest*>(
               &_GetBundlesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(GetBundlesRequest& a, GetBundlesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetBundlesRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetBundlesRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetBundlesRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetBundlesRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const GetBundlesRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const GetBundlesRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "game.battlemon.items.GetBundlesRequest";
  }
  protected:
  explicit GetBundlesRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:game.battlemon.items.GetBundlesRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_items_2eproto;
};
// -------------------------------------------------------------------

class GetBundlesResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:game.battlemon.items.GetBundlesResponse) */ {
 public:
  inline GetBundlesResponse() : GetBundlesResponse(nullptr) {}
  ~GetBundlesResponse() override;
  explicit PROTOBUF_CONSTEXPR GetBundlesResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetBundlesResponse(const GetBundlesResponse& from);
  GetBundlesResponse(GetBundlesResponse&& from) noexcept
    : GetBundlesResponse() {
    *this = ::std::move(from);
  }

  inline GetBundlesResponse& operator=(const GetBundlesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetBundlesResponse& operator=(GetBundlesResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetBundlesResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetBundlesResponse* internal_default_instance() {
    return reinterpret_cast<const GetBundlesResponse*>(
               &_GetBundlesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(GetBundlesResponse& a, GetBundlesResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetBundlesResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetBundlesResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetBundlesResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetBundlesResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetBundlesResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetBundlesResponse& from) {
    GetBundlesResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetBundlesResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "game.battlemon.items.GetBundlesResponse";
  }
  protected:
  explicit GetBundlesResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBundlesFieldNumber = 1,
  };
  // repeated .game.battlemon.items.WeaponBundle bundles = 1;
  int bundles_size() const;
  private:
  int _internal_bundles_size() const;
  public:
  void clear_bundles();
  ::game::battlemon::items::WeaponBundle* mutable_bundles(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::game::battlemon::items::WeaponBundle >*
      mutable_bundles();
  private:
  const ::game::battlemon::items::WeaponBundle& _internal_bundles(int index) const;
  ::game::battlemon::items::WeaponBundle* _internal_add_bundles();
  public:
  const ::game::battlemon::items::WeaponBundle& bundles(int index) const;
  ::game::battlemon::items::WeaponBundle* add_bundles();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::game::battlemon::items::WeaponBundle >&
      bundles() const;

  // @@protoc_insertion_point(class_scope:game.battlemon.items.GetBundlesResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::game::battlemon::items::WeaponBundle > bundles_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_items_2eproto;
};
// -------------------------------------------------------------------

class EditBundleRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:game.battlemon.items.EditBundleRequest) */ {
 public:
  inline EditBundleRequest() : EditBundleRequest(nullptr) {}
  ~EditBundleRequest() override;
  explicit PROTOBUF_CONSTEXPR EditBundleRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EditBundleRequest(const EditBundleRequest& from);
  EditBundleRequest(EditBundleRequest&& from) noexcept
    : EditBundleRequest() {
    *this = ::std::move(from);
  }

  inline EditBundleRequest& operator=(const EditBundleRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline EditBundleRequest& operator=(EditBundleRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EditBundleRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const EditBundleRequest* internal_default_instance() {
    return reinterpret_cast<const EditBundleRequest*>(
               &_EditBundleRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(EditBundleRequest& a, EditBundleRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(EditBundleRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EditBundleRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EditBundleRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EditBundleRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EditBundleRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EditBundleRequest& from) {
    EditBundleRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EditBundleRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "game.battlemon.items.EditBundleRequest";
  }
  protected:
  explicit EditBundleRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 2,
    kTitleFieldNumber = 3,
    kBundleNumFieldNumber = 1,
  };
  // repeated .game.battlemon.items.WeaponBundleItem items = 2;
  int items_size() const;
  private:
  int _internal_items_size() const;
  public:
  void clear_items();
  ::game::battlemon::items::WeaponBundleItem* mutable_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::game::battlemon::items::WeaponBundleItem >*
      mutable_items();
  private:
  const ::game::battlemon::items::WeaponBundleItem& _internal_items(int index) const;
  ::game::battlemon::items::WeaponBundleItem* _internal_add_items();
  public:
  const ::game::battlemon::items::WeaponBundleItem& items(int index) const;
  ::game::battlemon::items::WeaponBundleItem* add_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::game::battlemon::items::WeaponBundleItem >&
      items() const;

  // string title = 3;
  void clear_title();
  const std::string& title() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_title(ArgT0&& arg0, ArgT... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* title);
  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(const std::string& value);
  std::string* _internal_mutable_title();
  public:

  // int32 bundle_num = 1;
  void clear_bundle_num();
  int32_t bundle_num() const;
  void set_bundle_num(int32_t value);
  private:
  int32_t _internal_bundle_num() const;
  void _internal_set_bundle_num(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:game.battlemon.items.EditBundleRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::game::battlemon::items::WeaponBundleItem > items_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
    int32_t bundle_num_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_items_2eproto;
};
// -------------------------------------------------------------------

class AttachBundleRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:game.battlemon.items.AttachBundleRequest) */ {
 public:
  inline AttachBundleRequest() : AttachBundleRequest(nullptr) {}
  ~AttachBundleRequest() override;
  explicit PROTOBUF_CONSTEXPR AttachBundleRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AttachBundleRequest(const AttachBundleRequest& from);
  AttachBundleRequest(AttachBundleRequest&& from) noexcept
    : AttachBundleRequest() {
    *this = ::std::move(from);
  }

  inline AttachBundleRequest& operator=(const AttachBundleRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AttachBundleRequest& operator=(AttachBundleRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AttachBundleRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const AttachBundleRequest* internal_default_instance() {
    return reinterpret_cast<const AttachBundleRequest*>(
               &_AttachBundleRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(AttachBundleRequest& a, AttachBundleRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AttachBundleRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AttachBundleRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AttachBundleRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AttachBundleRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AttachBundleRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AttachBundleRequest& from) {
    AttachBundleRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AttachBundleRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "game.battlemon.items.AttachBundleRequest";
  }
  protected:
  explicit AttachBundleRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLemonIdFieldNumber = 2,
    kBundleNumFieldNumber = 1,
  };
  // string lemon_id = 2;
  void clear_lemon_id();
  const std::string& lemon_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_lemon_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_lemon_id();
  PROTOBUF_NODISCARD std::string* release_lemon_id();
  void set_allocated_lemon_id(std::string* lemon_id);
  private:
  const std::string& _internal_lemon_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_lemon_id(const std::string& value);
  std::string* _internal_mutable_lemon_id();
  public:

  // int32 bundle_num = 1;
  void clear_bundle_num();
  int32_t bundle_num() const;
  void set_bundle_num(int32_t value);
  private:
  int32_t _internal_bundle_num() const;
  void _internal_set_bundle_num(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:game.battlemon.items.AttachBundleRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr lemon_id_;
    int32_t bundle_num_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_items_2eproto;
};
// -------------------------------------------------------------------

class DetachBundleRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:game.battlemon.items.DetachBundleRequest) */ {
 public:
  inline DetachBundleRequest() : DetachBundleRequest(nullptr) {}
  ~DetachBundleRequest() override;
  explicit PROTOBUF_CONSTEXPR DetachBundleRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DetachBundleRequest(const DetachBundleRequest& from);
  DetachBundleRequest(DetachBundleRequest&& from) noexcept
    : DetachBundleRequest() {
    *this = ::std::move(from);
  }

  inline DetachBundleRequest& operator=(const DetachBundleRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DetachBundleRequest& operator=(DetachBundleRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DetachBundleRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DetachBundleRequest* internal_default_instance() {
    return reinterpret_cast<const DetachBundleRequest*>(
               &_DetachBundleRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(DetachBundleRequest& a, DetachBundleRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DetachBundleRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DetachBundleRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DetachBundleRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DetachBundleRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DetachBundleRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DetachBundleRequest& from) {
    DetachBundleRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DetachBundleRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "game.battlemon.items.DetachBundleRequest";
  }
  protected:
  explicit DetachBundleRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLemonIdFieldNumber = 2,
    kBundleNumFieldNumber = 1,
  };
  // string lemon_id = 2;
  void clear_lemon_id();
  const std::string& lemon_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_lemon_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_lemon_id();
  PROTOBUF_NODISCARD std::string* release_lemon_id();
  void set_allocated_lemon_id(std::string* lemon_id);
  private:
  const std::string& _internal_lemon_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_lemon_id(const std::string& value);
  std::string* _internal_mutable_lemon_id();
  public:

  // int32 bundle_num = 1;
  void clear_bundle_num();
  int32_t bundle_num() const;
  void set_bundle_num(int32_t value);
  private:
  int32_t _internal_bundle_num() const;
  void _internal_set_bundle_num(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:game.battlemon.items.DetachBundleRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr lemon_id_;
    int32_t bundle_num_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_items_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ItemsRequest

// -------------------------------------------------------------------

// ItemsResponse

// repeated .game.battlemon.items.Item items = 1;
inline int ItemsResponse::_internal_items_size() const {
  return _impl_.items_.size();
}
inline int ItemsResponse::items_size() const {
  return _internal_items_size();
}
inline void ItemsResponse::clear_items() {
  _impl_.items_.Clear();
}
inline ::game::battlemon::items::Item* ItemsResponse::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:game.battlemon.items.ItemsResponse.items)
  return _impl_.items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::game::battlemon::items::Item >*
ItemsResponse::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:game.battlemon.items.ItemsResponse.items)
  return &_impl_.items_;
}
inline const ::game::battlemon::items::Item& ItemsResponse::_internal_items(int index) const {
  return _impl_.items_.Get(index);
}
inline const ::game::battlemon::items::Item& ItemsResponse::items(int index) const {
  // @@protoc_insertion_point(field_get:game.battlemon.items.ItemsResponse.items)
  return _internal_items(index);
}
inline ::game::battlemon::items::Item* ItemsResponse::_internal_add_items() {
  return _impl_.items_.Add();
}
inline ::game::battlemon::items::Item* ItemsResponse::add_items() {
  ::game::battlemon::items::Item* _add = _internal_add_items();
  // @@protoc_insertion_point(field_add:game.battlemon.items.ItemsResponse.items)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::game::battlemon::items::Item >&
ItemsResponse::items() const {
  // @@protoc_insertion_point(field_list:game.battlemon.items.ItemsResponse.items)
  return _impl_.items_;
}

// -------------------------------------------------------------------

// Item

// .game.battlemon.items.NftItem nft = 1;
inline bool Item::_internal_has_nft() const {
  return item_case() == kNft;
}
inline bool Item::has_nft() const {
  return _internal_has_nft();
}
inline void Item::set_has_nft() {
  _impl_._oneof_case_[0] = kNft;
}
inline void Item::clear_nft() {
  if (_internal_has_nft()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.item_.nft_;
    }
    clear_has_item();
  }
}
inline ::game::battlemon::items::NftItem* Item::release_nft() {
  // @@protoc_insertion_point(field_release:game.battlemon.items.Item.nft)
  if (_internal_has_nft()) {
    clear_has_item();
    ::game::battlemon::items::NftItem* temp = _impl_.item_.nft_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.item_.nft_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::game::battlemon::items::NftItem& Item::_internal_nft() const {
  return _internal_has_nft()
      ? *_impl_.item_.nft_
      : reinterpret_cast< ::game::battlemon::items::NftItem&>(::game::battlemon::items::_NftItem_default_instance_);
}
inline const ::game::battlemon::items::NftItem& Item::nft() const {
  // @@protoc_insertion_point(field_get:game.battlemon.items.Item.nft)
  return _internal_nft();
}
inline ::game::battlemon::items::NftItem* Item::unsafe_arena_release_nft() {
  // @@protoc_insertion_point(field_unsafe_arena_release:game.battlemon.items.Item.nft)
  if (_internal_has_nft()) {
    clear_has_item();
    ::game::battlemon::items::NftItem* temp = _impl_.item_.nft_;
    _impl_.item_.nft_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Item::unsafe_arena_set_allocated_nft(::game::battlemon::items::NftItem* nft) {
  clear_item();
  if (nft) {
    set_has_nft();
    _impl_.item_.nft_ = nft;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:game.battlemon.items.Item.nft)
}
inline ::game::battlemon::items::NftItem* Item::_internal_mutable_nft() {
  if (!_internal_has_nft()) {
    clear_item();
    set_has_nft();
    _impl_.item_.nft_ = CreateMaybeMessage< ::game::battlemon::items::NftItem >(GetArenaForAllocation());
  }
  return _impl_.item_.nft_;
}
inline ::game::battlemon::items::NftItem* Item::mutable_nft() {
  ::game::battlemon::items::NftItem* _msg = _internal_mutable_nft();
  // @@protoc_insertion_point(field_mutable:game.battlemon.items.Item.nft)
  return _msg;
}

// .game.battlemon.items.NonNftItem non_nft = 2;
inline bool Item::_internal_has_non_nft() const {
  return item_case() == kNonNft;
}
inline bool Item::has_non_nft() const {
  return _internal_has_non_nft();
}
inline void Item::set_has_non_nft() {
  _impl_._oneof_case_[0] = kNonNft;
}
inline void Item::clear_non_nft() {
  if (_internal_has_non_nft()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.item_.non_nft_;
    }
    clear_has_item();
  }
}
inline ::game::battlemon::items::NonNftItem* Item::release_non_nft() {
  // @@protoc_insertion_point(field_release:game.battlemon.items.Item.non_nft)
  if (_internal_has_non_nft()) {
    clear_has_item();
    ::game::battlemon::items::NonNftItem* temp = _impl_.item_.non_nft_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.item_.non_nft_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::game::battlemon::items::NonNftItem& Item::_internal_non_nft() const {
  return _internal_has_non_nft()
      ? *_impl_.item_.non_nft_
      : reinterpret_cast< ::game::battlemon::items::NonNftItem&>(::game::battlemon::items::_NonNftItem_default_instance_);
}
inline const ::game::battlemon::items::NonNftItem& Item::non_nft() const {
  // @@protoc_insertion_point(field_get:game.battlemon.items.Item.non_nft)
  return _internal_non_nft();
}
inline ::game::battlemon::items::NonNftItem* Item::unsafe_arena_release_non_nft() {
  // @@protoc_insertion_point(field_unsafe_arena_release:game.battlemon.items.Item.non_nft)
  if (_internal_has_non_nft()) {
    clear_has_item();
    ::game::battlemon::items::NonNftItem* temp = _impl_.item_.non_nft_;
    _impl_.item_.non_nft_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Item::unsafe_arena_set_allocated_non_nft(::game::battlemon::items::NonNftItem* non_nft) {
  clear_item();
  if (non_nft) {
    set_has_non_nft();
    _impl_.item_.non_nft_ = non_nft;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:game.battlemon.items.Item.non_nft)
}
inline ::game::battlemon::items::NonNftItem* Item::_internal_mutable_non_nft() {
  if (!_internal_has_non_nft()) {
    clear_item();
    set_has_non_nft();
    _impl_.item_.non_nft_ = CreateMaybeMessage< ::game::battlemon::items::NonNftItem >(GetArenaForAllocation());
  }
  return _impl_.item_.non_nft_;
}
inline ::game::battlemon::items::NonNftItem* Item::mutable_non_nft() {
  ::game::battlemon::items::NonNftItem* _msg = _internal_mutable_non_nft();
  // @@protoc_insertion_point(field_mutable:game.battlemon.items.Item.non_nft)
  return _msg;
}

inline bool Item::has_item() const {
  return item_case() != ITEM_NOT_SET;
}
inline void Item::clear_has_item() {
  _impl_._oneof_case_[0] = ITEM_NOT_SET;
}
inline Item::ItemCase Item::item_case() const {
  return Item::ItemCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// NftItem

// string id = 1;
inline void NftItem::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& NftItem::id() const {
  // @@protoc_insertion_point(field_get:game.battlemon.items.NftItem.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NftItem::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:game.battlemon.items.NftItem.id)
}
inline std::string* NftItem::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:game.battlemon.items.NftItem.id)
  return _s;
}
inline const std::string& NftItem::_internal_id() const {
  return _impl_.id_.Get();
}
inline void NftItem::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* NftItem::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* NftItem::release_id() {
  // @@protoc_insertion_point(field_release:game.battlemon.items.NftItem.id)
  return _impl_.id_.Release();
}
inline void NftItem::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:game.battlemon.items.NftItem.id)
}

// string type = 2;
inline void NftItem::clear_type() {
  _impl_.type_.ClearToEmpty();
}
inline const std::string& NftItem::type() const {
  // @@protoc_insertion_point(field_get:game.battlemon.items.NftItem.type)
  return _internal_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NftItem::set_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:game.battlemon.items.NftItem.type)
}
inline std::string* NftItem::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:game.battlemon.items.NftItem.type)
  return _s;
}
inline const std::string& NftItem::_internal_type() const {
  return _impl_.type_.Get();
}
inline void NftItem::_internal_set_type(const std::string& value) {
  
  _impl_.type_.Set(value, GetArenaForAllocation());
}
inline std::string* NftItem::_internal_mutable_type() {
  
  return _impl_.type_.Mutable(GetArenaForAllocation());
}
inline std::string* NftItem::release_type() {
  // @@protoc_insertion_point(field_release:game.battlemon.items.NftItem.type)
  return _impl_.type_.Release();
}
inline void NftItem::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    
  } else {
    
  }
  _impl_.type_.SetAllocated(type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.type_.IsDefault()) {
    _impl_.type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:game.battlemon.items.NftItem.type)
}

// string owner = 3;
inline void NftItem::clear_owner() {
  _impl_.owner_.ClearToEmpty();
}
inline const std::string& NftItem::owner() const {
  // @@protoc_insertion_point(field_get:game.battlemon.items.NftItem.owner)
  return _internal_owner();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NftItem::set_owner(ArgT0&& arg0, ArgT... args) {
 
 _impl_.owner_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:game.battlemon.items.NftItem.owner)
}
inline std::string* NftItem::mutable_owner() {
  std::string* _s = _internal_mutable_owner();
  // @@protoc_insertion_point(field_mutable:game.battlemon.items.NftItem.owner)
  return _s;
}
inline const std::string& NftItem::_internal_owner() const {
  return _impl_.owner_.Get();
}
inline void NftItem::_internal_set_owner(const std::string& value) {
  
  _impl_.owner_.Set(value, GetArenaForAllocation());
}
inline std::string* NftItem::_internal_mutable_owner() {
  
  return _impl_.owner_.Mutable(GetArenaForAllocation());
}
inline std::string* NftItem::release_owner() {
  // @@protoc_insertion_point(field_release:game.battlemon.items.NftItem.owner)
  return _impl_.owner_.Release();
}
inline void NftItem::set_allocated_owner(std::string* owner) {
  if (owner != nullptr) {
    
  } else {
    
  }
  _impl_.owner_.SetAllocated(owner, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.owner_.IsDefault()) {
    _impl_.owner_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:game.battlemon.items.NftItem.owner)
}

// string url = 4;
inline void NftItem::clear_url() {
  _impl_.url_.ClearToEmpty();
}
inline const std::string& NftItem::url() const {
  // @@protoc_insertion_point(field_get:game.battlemon.items.NftItem.url)
  return _internal_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NftItem::set_url(ArgT0&& arg0, ArgT... args) {
 
 _impl_.url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:game.battlemon.items.NftItem.url)
}
inline std::string* NftItem::mutable_url() {
  std::string* _s = _internal_mutable_url();
  // @@protoc_insertion_point(field_mutable:game.battlemon.items.NftItem.url)
  return _s;
}
inline const std::string& NftItem::_internal_url() const {
  return _impl_.url_.Get();
}
inline void NftItem::_internal_set_url(const std::string& value) {
  
  _impl_.url_.Set(value, GetArenaForAllocation());
}
inline std::string* NftItem::_internal_mutable_url() {
  
  return _impl_.url_.Mutable(GetArenaForAllocation());
}
inline std::string* NftItem::release_url() {
  // @@protoc_insertion_point(field_release:game.battlemon.items.NftItem.url)
  return _impl_.url_.Release();
}
inline void NftItem::set_allocated_url(std::string* url) {
  if (url != nullptr) {
    
  } else {
    
  }
  _impl_.url_.SetAllocated(url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.url_.IsDefault()) {
    _impl_.url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:game.battlemon.items.NftItem.url)
}

// repeated .game.battlemon.items.Trait traits = 5;
inline int NftItem::_internal_traits_size() const {
  return _impl_.traits_.size();
}
inline int NftItem::traits_size() const {
  return _internal_traits_size();
}
inline void NftItem::clear_traits() {
  _impl_.traits_.Clear();
}
inline ::game::battlemon::items::Trait* NftItem::mutable_traits(int index) {
  // @@protoc_insertion_point(field_mutable:game.battlemon.items.NftItem.traits)
  return _impl_.traits_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::game::battlemon::items::Trait >*
NftItem::mutable_traits() {
  // @@protoc_insertion_point(field_mutable_list:game.battlemon.items.NftItem.traits)
  return &_impl_.traits_;
}
inline const ::game::battlemon::items::Trait& NftItem::_internal_traits(int index) const {
  return _impl_.traits_.Get(index);
}
inline const ::game::battlemon::items::Trait& NftItem::traits(int index) const {
  // @@protoc_insertion_point(field_get:game.battlemon.items.NftItem.traits)
  return _internal_traits(index);
}
inline ::game::battlemon::items::Trait* NftItem::_internal_add_traits() {
  return _impl_.traits_.Add();
}
inline ::game::battlemon::items::Trait* NftItem::add_traits() {
  ::game::battlemon::items::Trait* _add = _internal_add_traits();
  // @@protoc_insertion_point(field_add:game.battlemon.items.NftItem.traits)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::game::battlemon::items::Trait >&
NftItem::traits() const {
  // @@protoc_insertion_point(field_list:game.battlemon.items.NftItem.traits)
  return _impl_.traits_;
}

// int64 created_at = 6;
inline void NftItem::clear_created_at() {
  _impl_.created_at_ = int64_t{0};
}
inline int64_t NftItem::_internal_created_at() const {
  return _impl_.created_at_;
}
inline int64_t NftItem::created_at() const {
  // @@protoc_insertion_point(field_get:game.battlemon.items.NftItem.created_at)
  return _internal_created_at();
}
inline void NftItem::_internal_set_created_at(int64_t value) {
  
  _impl_.created_at_ = value;
}
inline void NftItem::set_created_at(int64_t value) {
  _internal_set_created_at(value);
  // @@protoc_insertion_point(field_set:game.battlemon.items.NftItem.created_at)
}

// repeated .game.battlemon.items.WeaponBundle attached_bundles = 7;
inline int NftItem::_internal_attached_bundles_size() const {
  return _impl_.attached_bundles_.size();
}
inline int NftItem::attached_bundles_size() const {
  return _internal_attached_bundles_size();
}
inline void NftItem::clear_attached_bundles() {
  _impl_.attached_bundles_.Clear();
}
inline ::game::battlemon::items::WeaponBundle* NftItem::mutable_attached_bundles(int index) {
  // @@protoc_insertion_point(field_mutable:game.battlemon.items.NftItem.attached_bundles)
  return _impl_.attached_bundles_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::game::battlemon::items::WeaponBundle >*
NftItem::mutable_attached_bundles() {
  // @@protoc_insertion_point(field_mutable_list:game.battlemon.items.NftItem.attached_bundles)
  return &_impl_.attached_bundles_;
}
inline const ::game::battlemon::items::WeaponBundle& NftItem::_internal_attached_bundles(int index) const {
  return _impl_.attached_bundles_.Get(index);
}
inline const ::game::battlemon::items::WeaponBundle& NftItem::attached_bundles(int index) const {
  // @@protoc_insertion_point(field_get:game.battlemon.items.NftItem.attached_bundles)
  return _internal_attached_bundles(index);
}
inline ::game::battlemon::items::WeaponBundle* NftItem::_internal_add_attached_bundles() {
  return _impl_.attached_bundles_.Add();
}
inline ::game::battlemon::items::WeaponBundle* NftItem::add_attached_bundles() {
  ::game::battlemon::items::WeaponBundle* _add = _internal_add_attached_bundles();
  // @@protoc_insertion_point(field_add:game.battlemon.items.NftItem.attached_bundles)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::game::battlemon::items::WeaponBundle >&
NftItem::attached_bundles() const {
  // @@protoc_insertion_point(field_list:game.battlemon.items.NftItem.attached_bundles)
  return _impl_.attached_bundles_;
}

// -------------------------------------------------------------------

// Trait

// string name = 1;
inline void Trait::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Trait::name() const {
  // @@protoc_insertion_point(field_get:game.battlemon.items.Trait.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Trait::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:game.battlemon.items.Trait.name)
}
inline std::string* Trait::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:game.battlemon.items.Trait.name)
  return _s;
}
inline const std::string& Trait::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Trait::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Trait::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Trait::release_name() {
  // @@protoc_insertion_point(field_release:game.battlemon.items.Trait.name)
  return _impl_.name_.Release();
}
inline void Trait::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:game.battlemon.items.Trait.name)
}

// string flavour = 2;
inline void Trait::clear_flavour() {
  _impl_.flavour_.ClearToEmpty();
}
inline const std::string& Trait::flavour() const {
  // @@protoc_insertion_point(field_get:game.battlemon.items.Trait.flavour)
  return _internal_flavour();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Trait::set_flavour(ArgT0&& arg0, ArgT... args) {
 
 _impl_.flavour_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:game.battlemon.items.Trait.flavour)
}
inline std::string* Trait::mutable_flavour() {
  std::string* _s = _internal_mutable_flavour();
  // @@protoc_insertion_point(field_mutable:game.battlemon.items.Trait.flavour)
  return _s;
}
inline const std::string& Trait::_internal_flavour() const {
  return _impl_.flavour_.Get();
}
inline void Trait::_internal_set_flavour(const std::string& value) {
  
  _impl_.flavour_.Set(value, GetArenaForAllocation());
}
inline std::string* Trait::_internal_mutable_flavour() {
  
  return _impl_.flavour_.Mutable(GetArenaForAllocation());
}
inline std::string* Trait::release_flavour() {
  // @@protoc_insertion_point(field_release:game.battlemon.items.Trait.flavour)
  return _impl_.flavour_.Release();
}
inline void Trait::set_allocated_flavour(std::string* flavour) {
  if (flavour != nullptr) {
    
  } else {
    
  }
  _impl_.flavour_.SetAllocated(flavour, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.flavour_.IsDefault()) {
    _impl_.flavour_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:game.battlemon.items.Trait.flavour)
}

// -------------------------------------------------------------------

// NonNftItem

// string id = 1;
inline void NonNftItem::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& NonNftItem::id() const {
  // @@protoc_insertion_point(field_get:game.battlemon.items.NonNftItem.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NonNftItem::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:game.battlemon.items.NonNftItem.id)
}
inline std::string* NonNftItem::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:game.battlemon.items.NonNftItem.id)
  return _s;
}
inline const std::string& NonNftItem::_internal_id() const {
  return _impl_.id_.Get();
}
inline void NonNftItem::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* NonNftItem::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* NonNftItem::release_id() {
  // @@protoc_insertion_point(field_release:game.battlemon.items.NonNftItem.id)
  return _impl_.id_.Release();
}
inline void NonNftItem::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:game.battlemon.items.NonNftItem.id)
}

// string owner = 2;
inline void NonNftItem::clear_owner() {
  _impl_.owner_.ClearToEmpty();
}
inline const std::string& NonNftItem::owner() const {
  // @@protoc_insertion_point(field_get:game.battlemon.items.NonNftItem.owner)
  return _internal_owner();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NonNftItem::set_owner(ArgT0&& arg0, ArgT... args) {
 
 _impl_.owner_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:game.battlemon.items.NonNftItem.owner)
}
inline std::string* NonNftItem::mutable_owner() {
  std::string* _s = _internal_mutable_owner();
  // @@protoc_insertion_point(field_mutable:game.battlemon.items.NonNftItem.owner)
  return _s;
}
inline const std::string& NonNftItem::_internal_owner() const {
  return _impl_.owner_.Get();
}
inline void NonNftItem::_internal_set_owner(const std::string& value) {
  
  _impl_.owner_.Set(value, GetArenaForAllocation());
}
inline std::string* NonNftItem::_internal_mutable_owner() {
  
  return _impl_.owner_.Mutable(GetArenaForAllocation());
}
inline std::string* NonNftItem::release_owner() {
  // @@protoc_insertion_point(field_release:game.battlemon.items.NonNftItem.owner)
  return _impl_.owner_.Release();
}
inline void NonNftItem::set_allocated_owner(std::string* owner) {
  if (owner != nullptr) {
    
  } else {
    
  }
  _impl_.owner_.SetAllocated(owner, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.owner_.IsDefault()) {
    _impl_.owner_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:game.battlemon.items.NonNftItem.owner)
}

// int32 level = 3;
inline void NonNftItem::clear_level() {
  _impl_.level_ = 0;
}
inline int32_t NonNftItem::_internal_level() const {
  return _impl_.level_;
}
inline int32_t NonNftItem::level() const {
  // @@protoc_insertion_point(field_get:game.battlemon.items.NonNftItem.level)
  return _internal_level();
}
inline void NonNftItem::_internal_set_level(int32_t value) {
  
  _impl_.level_ = value;
}
inline void NonNftItem::set_level(int32_t value) {
  _internal_set_level(value);
  // @@protoc_insertion_point(field_set:game.battlemon.items.NonNftItem.level)
}

// repeated .game.battlemon.items.WeaponBundle attached_bundles = 4;
inline int NonNftItem::_internal_attached_bundles_size() const {
  return _impl_.attached_bundles_.size();
}
inline int NonNftItem::attached_bundles_size() const {
  return _internal_attached_bundles_size();
}
inline void NonNftItem::clear_attached_bundles() {
  _impl_.attached_bundles_.Clear();
}
inline ::game::battlemon::items::WeaponBundle* NonNftItem::mutable_attached_bundles(int index) {
  // @@protoc_insertion_point(field_mutable:game.battlemon.items.NonNftItem.attached_bundles)
  return _impl_.attached_bundles_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::game::battlemon::items::WeaponBundle >*
NonNftItem::mutable_attached_bundles() {
  // @@protoc_insertion_point(field_mutable_list:game.battlemon.items.NonNftItem.attached_bundles)
  return &_impl_.attached_bundles_;
}
inline const ::game::battlemon::items::WeaponBundle& NonNftItem::_internal_attached_bundles(int index) const {
  return _impl_.attached_bundles_.Get(index);
}
inline const ::game::battlemon::items::WeaponBundle& NonNftItem::attached_bundles(int index) const {
  // @@protoc_insertion_point(field_get:game.battlemon.items.NonNftItem.attached_bundles)
  return _internal_attached_bundles(index);
}
inline ::game::battlemon::items::WeaponBundle* NonNftItem::_internal_add_attached_bundles() {
  return _impl_.attached_bundles_.Add();
}
inline ::game::battlemon::items::WeaponBundle* NonNftItem::add_attached_bundles() {
  ::game::battlemon::items::WeaponBundle* _add = _internal_add_attached_bundles();
  // @@protoc_insertion_point(field_add:game.battlemon.items.NonNftItem.attached_bundles)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::game::battlemon::items::WeaponBundle >&
NonNftItem::attached_bundles() const {
  // @@protoc_insertion_point(field_list:game.battlemon.items.NonNftItem.attached_bundles)
  return _impl_.attached_bundles_;
}

// -------------------------------------------------------------------

// WeaponBundle

// int32 bundle_num = 1;
inline void WeaponBundle::clear_bundle_num() {
  _impl_.bundle_num_ = 0;
}
inline int32_t WeaponBundle::_internal_bundle_num() const {
  return _impl_.bundle_num_;
}
inline int32_t WeaponBundle::bundle_num() const {
  // @@protoc_insertion_point(field_get:game.battlemon.items.WeaponBundle.bundle_num)
  return _internal_bundle_num();
}
inline void WeaponBundle::_internal_set_bundle_num(int32_t value) {
  
  _impl_.bundle_num_ = value;
}
inline void WeaponBundle::set_bundle_num(int32_t value) {
  _internal_set_bundle_num(value);
  // @@protoc_insertion_point(field_set:game.battlemon.items.WeaponBundle.bundle_num)
}

// repeated .game.battlemon.items.WeaponBundleItem items = 2;
inline int WeaponBundle::_internal_items_size() const {
  return _impl_.items_.size();
}
inline int WeaponBundle::items_size() const {
  return _internal_items_size();
}
inline void WeaponBundle::clear_items() {
  _impl_.items_.Clear();
}
inline ::game::battlemon::items::WeaponBundleItem* WeaponBundle::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:game.battlemon.items.WeaponBundle.items)
  return _impl_.items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::game::battlemon::items::WeaponBundleItem >*
WeaponBundle::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:game.battlemon.items.WeaponBundle.items)
  return &_impl_.items_;
}
inline const ::game::battlemon::items::WeaponBundleItem& WeaponBundle::_internal_items(int index) const {
  return _impl_.items_.Get(index);
}
inline const ::game::battlemon::items::WeaponBundleItem& WeaponBundle::items(int index) const {
  // @@protoc_insertion_point(field_get:game.battlemon.items.WeaponBundle.items)
  return _internal_items(index);
}
inline ::game::battlemon::items::WeaponBundleItem* WeaponBundle::_internal_add_items() {
  return _impl_.items_.Add();
}
inline ::game::battlemon::items::WeaponBundleItem* WeaponBundle::add_items() {
  ::game::battlemon::items::WeaponBundleItem* _add = _internal_add_items();
  // @@protoc_insertion_point(field_add:game.battlemon.items.WeaponBundle.items)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::game::battlemon::items::WeaponBundleItem >&
WeaponBundle::items() const {
  // @@protoc_insertion_point(field_list:game.battlemon.items.WeaponBundle.items)
  return _impl_.items_;
}

// string title = 3;
inline void WeaponBundle::clear_title() {
  _impl_.title_.ClearToEmpty();
}
inline const std::string& WeaponBundle::title() const {
  // @@protoc_insertion_point(field_get:game.battlemon.items.WeaponBundle.title)
  return _internal_title();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WeaponBundle::set_title(ArgT0&& arg0, ArgT... args) {
 
 _impl_.title_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:game.battlemon.items.WeaponBundle.title)
}
inline std::string* WeaponBundle::mutable_title() {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:game.battlemon.items.WeaponBundle.title)
  return _s;
}
inline const std::string& WeaponBundle::_internal_title() const {
  return _impl_.title_.Get();
}
inline void WeaponBundle::_internal_set_title(const std::string& value) {
  
  _impl_.title_.Set(value, GetArenaForAllocation());
}
inline std::string* WeaponBundle::_internal_mutable_title() {
  
  return _impl_.title_.Mutable(GetArenaForAllocation());
}
inline std::string* WeaponBundle::release_title() {
  // @@protoc_insertion_point(field_release:game.battlemon.items.WeaponBundle.title)
  return _impl_.title_.Release();
}
inline void WeaponBundle::set_allocated_title(std::string* title) {
  if (title != nullptr) {
    
  } else {
    
  }
  _impl_.title_.SetAllocated(title, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.title_.IsDefault()) {
    _impl_.title_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:game.battlemon.items.WeaponBundle.title)
}

// int32 level = 4;
inline void WeaponBundle::clear_level() {
  _impl_.level_ = 0;
}
inline int32_t WeaponBundle::_internal_level() const {
  return _impl_.level_;
}
inline int32_t WeaponBundle::level() const {
  // @@protoc_insertion_point(field_get:game.battlemon.items.WeaponBundle.level)
  return _internal_level();
}
inline void WeaponBundle::_internal_set_level(int32_t value) {
  
  _impl_.level_ = value;
}
inline void WeaponBundle::set_level(int32_t value) {
  _internal_set_level(value);
  // @@protoc_insertion_point(field_set:game.battlemon.items.WeaponBundle.level)
}

// -------------------------------------------------------------------

// WeaponBundleItem

// .game.battlemon.items.WeaponBundleItemType item_type = 1;
inline void WeaponBundleItem::clear_item_type() {
  _impl_.item_type_ = 0;
}
inline ::game::battlemon::items::WeaponBundleItemType WeaponBundleItem::_internal_item_type() const {
  return static_cast< ::game::battlemon::items::WeaponBundleItemType >(_impl_.item_type_);
}
inline ::game::battlemon::items::WeaponBundleItemType WeaponBundleItem::item_type() const {
  // @@protoc_insertion_point(field_get:game.battlemon.items.WeaponBundleItem.item_type)
  return _internal_item_type();
}
inline void WeaponBundleItem::_internal_set_item_type(::game::battlemon::items::WeaponBundleItemType value) {
  
  _impl_.item_type_ = value;
}
inline void WeaponBundleItem::set_item_type(::game::battlemon::items::WeaponBundleItemType value) {
  _internal_set_item_type(value);
  // @@protoc_insertion_point(field_set:game.battlemon.items.WeaponBundleItem.item_type)
}

// string skin = 2;
inline void WeaponBundleItem::clear_skin() {
  _impl_.skin_.ClearToEmpty();
}
inline const std::string& WeaponBundleItem::skin() const {
  // @@protoc_insertion_point(field_get:game.battlemon.items.WeaponBundleItem.skin)
  return _internal_skin();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WeaponBundleItem::set_skin(ArgT0&& arg0, ArgT... args) {
 
 _impl_.skin_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:game.battlemon.items.WeaponBundleItem.skin)
}
inline std::string* WeaponBundleItem::mutable_skin() {
  std::string* _s = _internal_mutable_skin();
  // @@protoc_insertion_point(field_mutable:game.battlemon.items.WeaponBundleItem.skin)
  return _s;
}
inline const std::string& WeaponBundleItem::_internal_skin() const {
  return _impl_.skin_.Get();
}
inline void WeaponBundleItem::_internal_set_skin(const std::string& value) {
  
  _impl_.skin_.Set(value, GetArenaForAllocation());
}
inline std::string* WeaponBundleItem::_internal_mutable_skin() {
  
  return _impl_.skin_.Mutable(GetArenaForAllocation());
}
inline std::string* WeaponBundleItem::release_skin() {
  // @@protoc_insertion_point(field_release:game.battlemon.items.WeaponBundleItem.skin)
  return _impl_.skin_.Release();
}
inline void WeaponBundleItem::set_allocated_skin(std::string* skin) {
  if (skin != nullptr) {
    
  } else {
    
  }
  _impl_.skin_.SetAllocated(skin, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.skin_.IsDefault()) {
    _impl_.skin_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:game.battlemon.items.WeaponBundleItem.skin)
}

// .game.battlemon.items.WeaponBundleSlotType slot_type = 3;
inline void WeaponBundleItem::clear_slot_type() {
  _impl_.slot_type_ = 0;
}
inline ::game::battlemon::items::WeaponBundleSlotType WeaponBundleItem::_internal_slot_type() const {
  return static_cast< ::game::battlemon::items::WeaponBundleSlotType >(_impl_.slot_type_);
}
inline ::game::battlemon::items::WeaponBundleSlotType WeaponBundleItem::slot_type() const {
  // @@protoc_insertion_point(field_get:game.battlemon.items.WeaponBundleItem.slot_type)
  return _internal_slot_type();
}
inline void WeaponBundleItem::_internal_set_slot_type(::game::battlemon::items::WeaponBundleSlotType value) {
  
  _impl_.slot_type_ = value;
}
inline void WeaponBundleItem::set_slot_type(::game::battlemon::items::WeaponBundleSlotType value) {
  _internal_set_slot_type(value);
  // @@protoc_insertion_point(field_set:game.battlemon.items.WeaponBundleItem.slot_type)
}

// -------------------------------------------------------------------

// GetBundlesRequest

// -------------------------------------------------------------------

// GetBundlesResponse

// repeated .game.battlemon.items.WeaponBundle bundles = 1;
inline int GetBundlesResponse::_internal_bundles_size() const {
  return _impl_.bundles_.size();
}
inline int GetBundlesResponse::bundles_size() const {
  return _internal_bundles_size();
}
inline void GetBundlesResponse::clear_bundles() {
  _impl_.bundles_.Clear();
}
inline ::game::battlemon::items::WeaponBundle* GetBundlesResponse::mutable_bundles(int index) {
  // @@protoc_insertion_point(field_mutable:game.battlemon.items.GetBundlesResponse.bundles)
  return _impl_.bundles_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::game::battlemon::items::WeaponBundle >*
GetBundlesResponse::mutable_bundles() {
  // @@protoc_insertion_point(field_mutable_list:game.battlemon.items.GetBundlesResponse.bundles)
  return &_impl_.bundles_;
}
inline const ::game::battlemon::items::WeaponBundle& GetBundlesResponse::_internal_bundles(int index) const {
  return _impl_.bundles_.Get(index);
}
inline const ::game::battlemon::items::WeaponBundle& GetBundlesResponse::bundles(int index) const {
  // @@protoc_insertion_point(field_get:game.battlemon.items.GetBundlesResponse.bundles)
  return _internal_bundles(index);
}
inline ::game::battlemon::items::WeaponBundle* GetBundlesResponse::_internal_add_bundles() {
  return _impl_.bundles_.Add();
}
inline ::game::battlemon::items::WeaponBundle* GetBundlesResponse::add_bundles() {
  ::game::battlemon::items::WeaponBundle* _add = _internal_add_bundles();
  // @@protoc_insertion_point(field_add:game.battlemon.items.GetBundlesResponse.bundles)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::game::battlemon::items::WeaponBundle >&
GetBundlesResponse::bundles() const {
  // @@protoc_insertion_point(field_list:game.battlemon.items.GetBundlesResponse.bundles)
  return _impl_.bundles_;
}

// -------------------------------------------------------------------

// EditBundleRequest

// int32 bundle_num = 1;
inline void EditBundleRequest::clear_bundle_num() {
  _impl_.bundle_num_ = 0;
}
inline int32_t EditBundleRequest::_internal_bundle_num() const {
  return _impl_.bundle_num_;
}
inline int32_t EditBundleRequest::bundle_num() const {
  // @@protoc_insertion_point(field_get:game.battlemon.items.EditBundleRequest.bundle_num)
  return _internal_bundle_num();
}
inline void EditBundleRequest::_internal_set_bundle_num(int32_t value) {
  
  _impl_.bundle_num_ = value;
}
inline void EditBundleRequest::set_bundle_num(int32_t value) {
  _internal_set_bundle_num(value);
  // @@protoc_insertion_point(field_set:game.battlemon.items.EditBundleRequest.bundle_num)
}

// repeated .game.battlemon.items.WeaponBundleItem items = 2;
inline int EditBundleRequest::_internal_items_size() const {
  return _impl_.items_.size();
}
inline int EditBundleRequest::items_size() const {
  return _internal_items_size();
}
inline void EditBundleRequest::clear_items() {
  _impl_.items_.Clear();
}
inline ::game::battlemon::items::WeaponBundleItem* EditBundleRequest::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:game.battlemon.items.EditBundleRequest.items)
  return _impl_.items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::game::battlemon::items::WeaponBundleItem >*
EditBundleRequest::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:game.battlemon.items.EditBundleRequest.items)
  return &_impl_.items_;
}
inline const ::game::battlemon::items::WeaponBundleItem& EditBundleRequest::_internal_items(int index) const {
  return _impl_.items_.Get(index);
}
inline const ::game::battlemon::items::WeaponBundleItem& EditBundleRequest::items(int index) const {
  // @@protoc_insertion_point(field_get:game.battlemon.items.EditBundleRequest.items)
  return _internal_items(index);
}
inline ::game::battlemon::items::WeaponBundleItem* EditBundleRequest::_internal_add_items() {
  return _impl_.items_.Add();
}
inline ::game::battlemon::items::WeaponBundleItem* EditBundleRequest::add_items() {
  ::game::battlemon::items::WeaponBundleItem* _add = _internal_add_items();
  // @@protoc_insertion_point(field_add:game.battlemon.items.EditBundleRequest.items)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::game::battlemon::items::WeaponBundleItem >&
EditBundleRequest::items() const {
  // @@protoc_insertion_point(field_list:game.battlemon.items.EditBundleRequest.items)
  return _impl_.items_;
}

// string title = 3;
inline void EditBundleRequest::clear_title() {
  _impl_.title_.ClearToEmpty();
}
inline const std::string& EditBundleRequest::title() const {
  // @@protoc_insertion_point(field_get:game.battlemon.items.EditBundleRequest.title)
  return _internal_title();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EditBundleRequest::set_title(ArgT0&& arg0, ArgT... args) {
 
 _impl_.title_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:game.battlemon.items.EditBundleRequest.title)
}
inline std::string* EditBundleRequest::mutable_title() {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:game.battlemon.items.EditBundleRequest.title)
  return _s;
}
inline const std::string& EditBundleRequest::_internal_title() const {
  return _impl_.title_.Get();
}
inline void EditBundleRequest::_internal_set_title(const std::string& value) {
  
  _impl_.title_.Set(value, GetArenaForAllocation());
}
inline std::string* EditBundleRequest::_internal_mutable_title() {
  
  return _impl_.title_.Mutable(GetArenaForAllocation());
}
inline std::string* EditBundleRequest::release_title() {
  // @@protoc_insertion_point(field_release:game.battlemon.items.EditBundleRequest.title)
  return _impl_.title_.Release();
}
inline void EditBundleRequest::set_allocated_title(std::string* title) {
  if (title != nullptr) {
    
  } else {
    
  }
  _impl_.title_.SetAllocated(title, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.title_.IsDefault()) {
    _impl_.title_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:game.battlemon.items.EditBundleRequest.title)
}

// -------------------------------------------------------------------

// AttachBundleRequest

// int32 bundle_num = 1;
inline void AttachBundleRequest::clear_bundle_num() {
  _impl_.bundle_num_ = 0;
}
inline int32_t AttachBundleRequest::_internal_bundle_num() const {
  return _impl_.bundle_num_;
}
inline int32_t AttachBundleRequest::bundle_num() const {
  // @@protoc_insertion_point(field_get:game.battlemon.items.AttachBundleRequest.bundle_num)
  return _internal_bundle_num();
}
inline void AttachBundleRequest::_internal_set_bundle_num(int32_t value) {
  
  _impl_.bundle_num_ = value;
}
inline void AttachBundleRequest::set_bundle_num(int32_t value) {
  _internal_set_bundle_num(value);
  // @@protoc_insertion_point(field_set:game.battlemon.items.AttachBundleRequest.bundle_num)
}

// string lemon_id = 2;
inline void AttachBundleRequest::clear_lemon_id() {
  _impl_.lemon_id_.ClearToEmpty();
}
inline const std::string& AttachBundleRequest::lemon_id() const {
  // @@protoc_insertion_point(field_get:game.battlemon.items.AttachBundleRequest.lemon_id)
  return _internal_lemon_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AttachBundleRequest::set_lemon_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.lemon_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:game.battlemon.items.AttachBundleRequest.lemon_id)
}
inline std::string* AttachBundleRequest::mutable_lemon_id() {
  std::string* _s = _internal_mutable_lemon_id();
  // @@protoc_insertion_point(field_mutable:game.battlemon.items.AttachBundleRequest.lemon_id)
  return _s;
}
inline const std::string& AttachBundleRequest::_internal_lemon_id() const {
  return _impl_.lemon_id_.Get();
}
inline void AttachBundleRequest::_internal_set_lemon_id(const std::string& value) {
  
  _impl_.lemon_id_.Set(value, GetArenaForAllocation());
}
inline std::string* AttachBundleRequest::_internal_mutable_lemon_id() {
  
  return _impl_.lemon_id_.Mutable(GetArenaForAllocation());
}
inline std::string* AttachBundleRequest::release_lemon_id() {
  // @@protoc_insertion_point(field_release:game.battlemon.items.AttachBundleRequest.lemon_id)
  return _impl_.lemon_id_.Release();
}
inline void AttachBundleRequest::set_allocated_lemon_id(std::string* lemon_id) {
  if (lemon_id != nullptr) {
    
  } else {
    
  }
  _impl_.lemon_id_.SetAllocated(lemon_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.lemon_id_.IsDefault()) {
    _impl_.lemon_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:game.battlemon.items.AttachBundleRequest.lemon_id)
}

// -------------------------------------------------------------------

// DetachBundleRequest

// int32 bundle_num = 1;
inline void DetachBundleRequest::clear_bundle_num() {
  _impl_.bundle_num_ = 0;
}
inline int32_t DetachBundleRequest::_internal_bundle_num() const {
  return _impl_.bundle_num_;
}
inline int32_t DetachBundleRequest::bundle_num() const {
  // @@protoc_insertion_point(field_get:game.battlemon.items.DetachBundleRequest.bundle_num)
  return _internal_bundle_num();
}
inline void DetachBundleRequest::_internal_set_bundle_num(int32_t value) {
  
  _impl_.bundle_num_ = value;
}
inline void DetachBundleRequest::set_bundle_num(int32_t value) {
  _internal_set_bundle_num(value);
  // @@protoc_insertion_point(field_set:game.battlemon.items.DetachBundleRequest.bundle_num)
}

// string lemon_id = 2;
inline void DetachBundleRequest::clear_lemon_id() {
  _impl_.lemon_id_.ClearToEmpty();
}
inline const std::string& DetachBundleRequest::lemon_id() const {
  // @@protoc_insertion_point(field_get:game.battlemon.items.DetachBundleRequest.lemon_id)
  return _internal_lemon_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DetachBundleRequest::set_lemon_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.lemon_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:game.battlemon.items.DetachBundleRequest.lemon_id)
}
inline std::string* DetachBundleRequest::mutable_lemon_id() {
  std::string* _s = _internal_mutable_lemon_id();
  // @@protoc_insertion_point(field_mutable:game.battlemon.items.DetachBundleRequest.lemon_id)
  return _s;
}
inline const std::string& DetachBundleRequest::_internal_lemon_id() const {
  return _impl_.lemon_id_.Get();
}
inline void DetachBundleRequest::_internal_set_lemon_id(const std::string& value) {
  
  _impl_.lemon_id_.Set(value, GetArenaForAllocation());
}
inline std::string* DetachBundleRequest::_internal_mutable_lemon_id() {
  
  return _impl_.lemon_id_.Mutable(GetArenaForAllocation());
}
inline std::string* DetachBundleRequest::release_lemon_id() {
  // @@protoc_insertion_point(field_release:game.battlemon.items.DetachBundleRequest.lemon_id)
  return _impl_.lemon_id_.Release();
}
inline void DetachBundleRequest::set_allocated_lemon_id(std::string* lemon_id) {
  if (lemon_id != nullptr) {
    
  } else {
    
  }
  _impl_.lemon_id_.SetAllocated(lemon_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.lemon_id_.IsDefault()) {
    _impl_.lemon_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:game.battlemon.items.DetachBundleRequest.lemon_id)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace items
}  // namespace battlemon
}  // namespace game

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::game::battlemon::items::WeaponBundleItemType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::game::battlemon::items::WeaponBundleItemType>() {
  return ::game::battlemon::items::WeaponBundleItemType_descriptor();
}
template <> struct is_proto_enum< ::game::battlemon::items::WeaponBundleSlotType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::game::battlemon::items::WeaponBundleSlotType>() {
  return ::game::battlemon::items::WeaponBundleSlotType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_items_2eproto
