// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: items.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_items_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_items_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021005 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "common.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_items_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_items_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_items_2eproto;
namespace game {
namespace battlemon {
namespace items {
class AttachBundleRequest;
struct AttachBundleRequestDefaultTypeInternal;
extern AttachBundleRequestDefaultTypeInternal _AttachBundleRequest_default_instance_;
class DetachBundleRequest;
struct DetachBundleRequestDefaultTypeInternal;
extern DetachBundleRequestDefaultTypeInternal _DetachBundleRequest_default_instance_;
class EditBundleRequest;
struct EditBundleRequestDefaultTypeInternal;
extern EditBundleRequestDefaultTypeInternal _EditBundleRequest_default_instance_;
class GetBundlesRequest;
struct GetBundlesRequestDefaultTypeInternal;
extern GetBundlesRequestDefaultTypeInternal _GetBundlesRequest_default_instance_;
class GetBundlesResponse;
struct GetBundlesResponseDefaultTypeInternal;
extern GetBundlesResponseDefaultTypeInternal _GetBundlesResponse_default_instance_;
class Item;
struct ItemDefaultTypeInternal;
extern ItemDefaultTypeInternal _Item_default_instance_;
class ItemsRequest;
struct ItemsRequestDefaultTypeInternal;
extern ItemsRequestDefaultTypeInternal _ItemsRequest_default_instance_;
class ItemsResponse;
struct ItemsResponseDefaultTypeInternal;
extern ItemsResponseDefaultTypeInternal _ItemsResponse_default_instance_;
class LemonModel;
struct LemonModelDefaultTypeInternal;
extern LemonModelDefaultTypeInternal _LemonModel_default_instance_;
class OutfitModel;
struct OutfitModelDefaultTypeInternal;
extern OutfitModelDefaultTypeInternal _OutfitModel_default_instance_;
class WeaponBundle;
struct WeaponBundleDefaultTypeInternal;
extern WeaponBundleDefaultTypeInternal _WeaponBundle_default_instance_;
class WeaponBundleItem;
struct WeaponBundleItemDefaultTypeInternal;
extern WeaponBundleItemDefaultTypeInternal _WeaponBundleItem_default_instance_;
}  // namespace items
}  // namespace battlemon
}  // namespace game
PROTOBUF_NAMESPACE_OPEN
template<> ::game::battlemon::items::AttachBundleRequest* Arena::CreateMaybeMessage<::game::battlemon::items::AttachBundleRequest>(Arena*);
template<> ::game::battlemon::items::DetachBundleRequest* Arena::CreateMaybeMessage<::game::battlemon::items::DetachBundleRequest>(Arena*);
template<> ::game::battlemon::items::EditBundleRequest* Arena::CreateMaybeMessage<::game::battlemon::items::EditBundleRequest>(Arena*);
template<> ::game::battlemon::items::GetBundlesRequest* Arena::CreateMaybeMessage<::game::battlemon::items::GetBundlesRequest>(Arena*);
template<> ::game::battlemon::items::GetBundlesResponse* Arena::CreateMaybeMessage<::game::battlemon::items::GetBundlesResponse>(Arena*);
template<> ::game::battlemon::items::Item* Arena::CreateMaybeMessage<::game::battlemon::items::Item>(Arena*);
template<> ::game::battlemon::items::ItemsRequest* Arena::CreateMaybeMessage<::game::battlemon::items::ItemsRequest>(Arena*);
template<> ::game::battlemon::items::ItemsResponse* Arena::CreateMaybeMessage<::game::battlemon::items::ItemsResponse>(Arena*);
template<> ::game::battlemon::items::LemonModel* Arena::CreateMaybeMessage<::game::battlemon::items::LemonModel>(Arena*);
template<> ::game::battlemon::items::OutfitModel* Arena::CreateMaybeMessage<::game::battlemon::items::OutfitModel>(Arena*);
template<> ::game::battlemon::items::WeaponBundle* Arena::CreateMaybeMessage<::game::battlemon::items::WeaponBundle>(Arena*);
template<> ::game::battlemon::items::WeaponBundleItem* Arena::CreateMaybeMessage<::game::battlemon::items::WeaponBundleItem>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace game {
namespace battlemon {
namespace items {

enum OutfitKind : int {
  CAP = 0,
  CLOTH = 1,
  FIRE_ARM = 2,
  COLD_ARM = 3,
  BACK = 4,
  OutfitKind_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  OutfitKind_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool OutfitKind_IsValid(int value);
constexpr OutfitKind OutfitKind_MIN = CAP;
constexpr OutfitKind OutfitKind_MAX = BACK;
constexpr int OutfitKind_ARRAYSIZE = OutfitKind_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* OutfitKind_descriptor();
template<typename T>
inline const std::string& OutfitKind_Name(T enum_t_value) {
  static_assert(::std::is_same<T, OutfitKind>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function OutfitKind_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    OutfitKind_descriptor(), enum_t_value);
}
inline bool OutfitKind_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, OutfitKind* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<OutfitKind>(
    OutfitKind_descriptor(), name, value);
}
enum WeaponBundleItemType : int {
  BUNDLE_ITEM_PRIMARY = 0,
  BUNDLE_ITEM_SECONDARY = 1,
  BUNDLE_ITEM_MELEE = 2,
  BUNDLE_ITEM_TACTICAL = 3,
  BUNDLE_ITEM_MILITARY = 4,
  BUNDLE_ITEM_PERK = 5,
  WeaponBundleItemType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  WeaponBundleItemType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool WeaponBundleItemType_IsValid(int value);
constexpr WeaponBundleItemType WeaponBundleItemType_MIN = BUNDLE_ITEM_PRIMARY;
constexpr WeaponBundleItemType WeaponBundleItemType_MAX = BUNDLE_ITEM_PERK;
constexpr int WeaponBundleItemType_ARRAYSIZE = WeaponBundleItemType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* WeaponBundleItemType_descriptor();
template<typename T>
inline const std::string& WeaponBundleItemType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, WeaponBundleItemType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function WeaponBundleItemType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    WeaponBundleItemType_descriptor(), enum_t_value);
}
inline bool WeaponBundleItemType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, WeaponBundleItemType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<WeaponBundleItemType>(
    WeaponBundleItemType_descriptor(), name, value);
}
enum WeaponBundleSlotType : int {
  BUNDLE_SLOT_PRIMARY = 0,
  BUNDLE_SLOT_SECONDARY = 1,
  BUNDLE_SLOT_MELEE = 2,
  BUNDLE_SLOT_TACTICAL_ONE = 3,
  BUNDLE_SLOT_TACTICAL_TWO = 4,
  BUNDLE_SLOT_MILITARY_ONE = 5,
  BUNDLE_SLOT_MILITARY_TWO = 6,
  BUNDLE_SLOT_PERK_ONE = 7,
  BUNDLE_SLOT_PERK_TWO = 8,
  WeaponBundleSlotType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  WeaponBundleSlotType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool WeaponBundleSlotType_IsValid(int value);
constexpr WeaponBundleSlotType WeaponBundleSlotType_MIN = BUNDLE_SLOT_PRIMARY;
constexpr WeaponBundleSlotType WeaponBundleSlotType_MAX = BUNDLE_SLOT_PERK_TWO;
constexpr int WeaponBundleSlotType_ARRAYSIZE = WeaponBundleSlotType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* WeaponBundleSlotType_descriptor();
template<typename T>
inline const std::string& WeaponBundleSlotType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, WeaponBundleSlotType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function WeaponBundleSlotType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    WeaponBundleSlotType_descriptor(), enum_t_value);
}
inline bool WeaponBundleSlotType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, WeaponBundleSlotType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<WeaponBundleSlotType>(
    WeaponBundleSlotType_descriptor(), name, value);
}
// ===================================================================

class ItemsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:game.battlemon.items.ItemsRequest) */ {
 public:
  inline ItemsRequest() : ItemsRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR ItemsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ItemsRequest(const ItemsRequest& from);
  ItemsRequest(ItemsRequest&& from) noexcept
    : ItemsRequest() {
    *this = ::std::move(from);
  }

  inline ItemsRequest& operator=(const ItemsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ItemsRequest& operator=(ItemsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ItemsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ItemsRequest* internal_default_instance() {
    return reinterpret_cast<const ItemsRequest*>(
               &_ItemsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(ItemsRequest& a, ItemsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ItemsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ItemsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ItemsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ItemsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ItemsRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ItemsRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "game.battlemon.items.ItemsRequest";
  }
  protected:
  explicit ItemsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:game.battlemon.items.ItemsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_items_2eproto;
};
// -------------------------------------------------------------------

class ItemsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:game.battlemon.items.ItemsResponse) */ {
 public:
  inline ItemsResponse() : ItemsResponse(nullptr) {}
  ~ItemsResponse() override;
  explicit PROTOBUF_CONSTEXPR ItemsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ItemsResponse(const ItemsResponse& from);
  ItemsResponse(ItemsResponse&& from) noexcept
    : ItemsResponse() {
    *this = ::std::move(from);
  }

  inline ItemsResponse& operator=(const ItemsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ItemsResponse& operator=(ItemsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ItemsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ItemsResponse* internal_default_instance() {
    return reinterpret_cast<const ItemsResponse*>(
               &_ItemsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ItemsResponse& a, ItemsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ItemsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ItemsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ItemsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ItemsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ItemsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ItemsResponse& from) {
    ItemsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ItemsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "game.battlemon.items.ItemsResponse";
  }
  protected:
  explicit ItemsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 1,
  };
  // repeated .game.battlemon.items.Item items = 1;
  int items_size() const;
  private:
  int _internal_items_size() const;
  public:
  void clear_items();
  ::game::battlemon::items::Item* mutable_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::game::battlemon::items::Item >*
      mutable_items();
  private:
  const ::game::battlemon::items::Item& _internal_items(int index) const;
  ::game::battlemon::items::Item* _internal_add_items();
  public:
  const ::game::battlemon::items::Item& items(int index) const;
  ::game::battlemon::items::Item* add_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::game::battlemon::items::Item >&
      items() const;

  // @@protoc_insertion_point(class_scope:game.battlemon.items.ItemsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::game::battlemon::items::Item > items_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_items_2eproto;
};
// -------------------------------------------------------------------

class Item final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:game.battlemon.items.Item) */ {
 public:
  inline Item() : Item(nullptr) {}
  ~Item() override;
  explicit PROTOBUF_CONSTEXPR Item(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Item(const Item& from);
  Item(Item&& from) noexcept
    : Item() {
    *this = ::std::move(from);
  }

  inline Item& operator=(const Item& from) {
    CopyFrom(from);
    return *this;
  }
  inline Item& operator=(Item&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Item& default_instance() {
    return *internal_default_instance();
  }
  enum ModelCase {
    kLemon = 5,
    kOutfit = 6,
    MODEL_NOT_SET = 0,
  };

  static inline const Item* internal_default_instance() {
    return reinterpret_cast<const Item*>(
               &_Item_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Item& a, Item& b) {
    a.Swap(&b);
  }
  inline void Swap(Item* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Item* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Item* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Item>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Item& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Item& from) {
    Item::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Item* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "game.battlemon.items.Item";
  }
  protected:
  explicit Item(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTokenIdFieldNumber = 1,
    kMediaFieldNumber = 2,
    kOwnerIdFieldNumber = 3,
    kInFightFieldNumber = 4,
    kLemonFieldNumber = 5,
    kOutfitFieldNumber = 6,
  };
  // string token_id = 1;
  void clear_token_id();
  const std::string& token_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_token_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_token_id();
  PROTOBUF_NODISCARD std::string* release_token_id();
  void set_allocated_token_id(std::string* token_id);
  private:
  const std::string& _internal_token_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_token_id(const std::string& value);
  std::string* _internal_mutable_token_id();
  public:

  // string media = 2;
  void clear_media();
  const std::string& media() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_media(ArgT0&& arg0, ArgT... args);
  std::string* mutable_media();
  PROTOBUF_NODISCARD std::string* release_media();
  void set_allocated_media(std::string* media);
  private:
  const std::string& _internal_media() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_media(const std::string& value);
  std::string* _internal_mutable_media();
  public:

  // string owner_id = 3;
  void clear_owner_id();
  const std::string& owner_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_owner_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_owner_id();
  PROTOBUF_NODISCARD std::string* release_owner_id();
  void set_allocated_owner_id(std::string* owner_id);
  private:
  const std::string& _internal_owner_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_owner_id(const std::string& value);
  std::string* _internal_mutable_owner_id();
  public:

  // bool in_fight = 4;
  void clear_in_fight();
  bool in_fight() const;
  void set_in_fight(bool value);
  private:
  bool _internal_in_fight() const;
  void _internal_set_in_fight(bool value);
  public:

  // .game.battlemon.items.LemonModel lemon = 5;
  bool has_lemon() const;
  private:
  bool _internal_has_lemon() const;
  public:
  void clear_lemon();
  const ::game::battlemon::items::LemonModel& lemon() const;
  PROTOBUF_NODISCARD ::game::battlemon::items::LemonModel* release_lemon();
  ::game::battlemon::items::LemonModel* mutable_lemon();
  void set_allocated_lemon(::game::battlemon::items::LemonModel* lemon);
  private:
  const ::game::battlemon::items::LemonModel& _internal_lemon() const;
  ::game::battlemon::items::LemonModel* _internal_mutable_lemon();
  public:
  void unsafe_arena_set_allocated_lemon(
      ::game::battlemon::items::LemonModel* lemon);
  ::game::battlemon::items::LemonModel* unsafe_arena_release_lemon();

  // .game.battlemon.items.OutfitModel outfit = 6;
  bool has_outfit() const;
  private:
  bool _internal_has_outfit() const;
  public:
  void clear_outfit();
  const ::game::battlemon::items::OutfitModel& outfit() const;
  PROTOBUF_NODISCARD ::game::battlemon::items::OutfitModel* release_outfit();
  ::game::battlemon::items::OutfitModel* mutable_outfit();
  void set_allocated_outfit(::game::battlemon::items::OutfitModel* outfit);
  private:
  const ::game::battlemon::items::OutfitModel& _internal_outfit() const;
  ::game::battlemon::items::OutfitModel* _internal_mutable_outfit();
  public:
  void unsafe_arena_set_allocated_outfit(
      ::game::battlemon::items::OutfitModel* outfit);
  ::game::battlemon::items::OutfitModel* unsafe_arena_release_outfit();

  void clear_model();
  ModelCase model_case() const;
  // @@protoc_insertion_point(class_scope:game.battlemon.items.Item)
 private:
  class _Internal;
  void set_has_lemon();
  void set_has_outfit();

  inline bool has_model() const;
  inline void clear_has_model();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr token_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr media_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr owner_id_;
    bool in_fight_;
    union ModelUnion {
      constexpr ModelUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::game::battlemon::items::LemonModel* lemon_;
      ::game::battlemon::items::OutfitModel* outfit_;
    } model_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_items_2eproto;
};
// -------------------------------------------------------------------

class LemonModel final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:game.battlemon.items.LemonModel) */ {
 public:
  inline LemonModel() : LemonModel(nullptr) {}
  ~LemonModel() override;
  explicit PROTOBUF_CONSTEXPR LemonModel(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LemonModel(const LemonModel& from);
  LemonModel(LemonModel&& from) noexcept
    : LemonModel() {
    *this = ::std::move(from);
  }

  inline LemonModel& operator=(const LemonModel& from) {
    CopyFrom(from);
    return *this;
  }
  inline LemonModel& operator=(LemonModel&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LemonModel& default_instance() {
    return *internal_default_instance();
  }
  static inline const LemonModel* internal_default_instance() {
    return reinterpret_cast<const LemonModel*>(
               &_LemonModel_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(LemonModel& a, LemonModel& b) {
    a.Swap(&b);
  }
  inline void Swap(LemonModel* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LemonModel* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LemonModel* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LemonModel>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LemonModel& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LemonModel& from) {
    LemonModel::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LemonModel* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "game.battlemon.items.LemonModel";
  }
  protected:
  explicit LemonModel(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAttachedBundlesFieldNumber = 11,
    kExoFieldNumber = 3,
    kEyesFieldNumber = 4,
    kHeadFieldNumber = 5,
    kTeethFieldNumber = 6,
    kFaceFieldNumber = 7,
    kCapFieldNumber = 1,
    kClothFieldNumber = 2,
    kFireArmFieldNumber = 8,
    kColdArmFieldNumber = 9,
    kBackFieldNumber = 10,
  };
  // repeated .game.battlemon.items.WeaponBundle attached_bundles = 11;
  int attached_bundles_size() const;
  private:
  int _internal_attached_bundles_size() const;
  public:
  void clear_attached_bundles();
  ::game::battlemon::items::WeaponBundle* mutable_attached_bundles(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::game::battlemon::items::WeaponBundle >*
      mutable_attached_bundles();
  private:
  const ::game::battlemon::items::WeaponBundle& _internal_attached_bundles(int index) const;
  ::game::battlemon::items::WeaponBundle* _internal_add_attached_bundles();
  public:
  const ::game::battlemon::items::WeaponBundle& attached_bundles(int index) const;
  ::game::battlemon::items::WeaponBundle* add_attached_bundles();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::game::battlemon::items::WeaponBundle >&
      attached_bundles() const;

  // string exo = 3;
  void clear_exo();
  const std::string& exo() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_exo(ArgT0&& arg0, ArgT... args);
  std::string* mutable_exo();
  PROTOBUF_NODISCARD std::string* release_exo();
  void set_allocated_exo(std::string* exo);
  private:
  const std::string& _internal_exo() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_exo(const std::string& value);
  std::string* _internal_mutable_exo();
  public:

  // string eyes = 4;
  void clear_eyes();
  const std::string& eyes() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_eyes(ArgT0&& arg0, ArgT... args);
  std::string* mutable_eyes();
  PROTOBUF_NODISCARD std::string* release_eyes();
  void set_allocated_eyes(std::string* eyes);
  private:
  const std::string& _internal_eyes() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_eyes(const std::string& value);
  std::string* _internal_mutable_eyes();
  public:

  // string head = 5;
  void clear_head();
  const std::string& head() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_head(ArgT0&& arg0, ArgT... args);
  std::string* mutable_head();
  PROTOBUF_NODISCARD std::string* release_head();
  void set_allocated_head(std::string* head);
  private:
  const std::string& _internal_head() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_head(const std::string& value);
  std::string* _internal_mutable_head();
  public:

  // string teeth = 6;
  void clear_teeth();
  const std::string& teeth() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_teeth(ArgT0&& arg0, ArgT... args);
  std::string* mutable_teeth();
  PROTOBUF_NODISCARD std::string* release_teeth();
  void set_allocated_teeth(std::string* teeth);
  private:
  const std::string& _internal_teeth() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_teeth(const std::string& value);
  std::string* _internal_mutable_teeth();
  public:

  // string face = 7;
  void clear_face();
  const std::string& face() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_face(ArgT0&& arg0, ArgT... args);
  std::string* mutable_face();
  PROTOBUF_NODISCARD std::string* release_face();
  void set_allocated_face(std::string* face);
  private:
  const std::string& _internal_face() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_face(const std::string& value);
  std::string* _internal_mutable_face();
  public:

  // .game.battlemon.items.OutfitModel cap = 1;
  bool has_cap() const;
  private:
  bool _internal_has_cap() const;
  public:
  void clear_cap();
  const ::game::battlemon::items::OutfitModel& cap() const;
  PROTOBUF_NODISCARD ::game::battlemon::items::OutfitModel* release_cap();
  ::game::battlemon::items::OutfitModel* mutable_cap();
  void set_allocated_cap(::game::battlemon::items::OutfitModel* cap);
  private:
  const ::game::battlemon::items::OutfitModel& _internal_cap() const;
  ::game::battlemon::items::OutfitModel* _internal_mutable_cap();
  public:
  void unsafe_arena_set_allocated_cap(
      ::game::battlemon::items::OutfitModel* cap);
  ::game::battlemon::items::OutfitModel* unsafe_arena_release_cap();

  // .game.battlemon.items.OutfitModel cloth = 2;
  bool has_cloth() const;
  private:
  bool _internal_has_cloth() const;
  public:
  void clear_cloth();
  const ::game::battlemon::items::OutfitModel& cloth() const;
  PROTOBUF_NODISCARD ::game::battlemon::items::OutfitModel* release_cloth();
  ::game::battlemon::items::OutfitModel* mutable_cloth();
  void set_allocated_cloth(::game::battlemon::items::OutfitModel* cloth);
  private:
  const ::game::battlemon::items::OutfitModel& _internal_cloth() const;
  ::game::battlemon::items::OutfitModel* _internal_mutable_cloth();
  public:
  void unsafe_arena_set_allocated_cloth(
      ::game::battlemon::items::OutfitModel* cloth);
  ::game::battlemon::items::OutfitModel* unsafe_arena_release_cloth();

  // .game.battlemon.items.OutfitModel fire_arm = 8;
  bool has_fire_arm() const;
  private:
  bool _internal_has_fire_arm() const;
  public:
  void clear_fire_arm();
  const ::game::battlemon::items::OutfitModel& fire_arm() const;
  PROTOBUF_NODISCARD ::game::battlemon::items::OutfitModel* release_fire_arm();
  ::game::battlemon::items::OutfitModel* mutable_fire_arm();
  void set_allocated_fire_arm(::game::battlemon::items::OutfitModel* fire_arm);
  private:
  const ::game::battlemon::items::OutfitModel& _internal_fire_arm() const;
  ::game::battlemon::items::OutfitModel* _internal_mutable_fire_arm();
  public:
  void unsafe_arena_set_allocated_fire_arm(
      ::game::battlemon::items::OutfitModel* fire_arm);
  ::game::battlemon::items::OutfitModel* unsafe_arena_release_fire_arm();

  // .game.battlemon.items.OutfitModel cold_arm = 9;
  bool has_cold_arm() const;
  private:
  bool _internal_has_cold_arm() const;
  public:
  void clear_cold_arm();
  const ::game::battlemon::items::OutfitModel& cold_arm() const;
  PROTOBUF_NODISCARD ::game::battlemon::items::OutfitModel* release_cold_arm();
  ::game::battlemon::items::OutfitModel* mutable_cold_arm();
  void set_allocated_cold_arm(::game::battlemon::items::OutfitModel* cold_arm);
  private:
  const ::game::battlemon::items::OutfitModel& _internal_cold_arm() const;
  ::game::battlemon::items::OutfitModel* _internal_mutable_cold_arm();
  public:
  void unsafe_arena_set_allocated_cold_arm(
      ::game::battlemon::items::OutfitModel* cold_arm);
  ::game::battlemon::items::OutfitModel* unsafe_arena_release_cold_arm();

  // .game.battlemon.items.OutfitModel back = 10;
  bool has_back() const;
  private:
  bool _internal_has_back() const;
  public:
  void clear_back();
  const ::game::battlemon::items::OutfitModel& back() const;
  PROTOBUF_NODISCARD ::game::battlemon::items::OutfitModel* release_back();
  ::game::battlemon::items::OutfitModel* mutable_back();
  void set_allocated_back(::game::battlemon::items::OutfitModel* back);
  private:
  const ::game::battlemon::items::OutfitModel& _internal_back() const;
  ::game::battlemon::items::OutfitModel* _internal_mutable_back();
  public:
  void unsafe_arena_set_allocated_back(
      ::game::battlemon::items::OutfitModel* back);
  ::game::battlemon::items::OutfitModel* unsafe_arena_release_back();

  // @@protoc_insertion_point(class_scope:game.battlemon.items.LemonModel)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::game::battlemon::items::WeaponBundle > attached_bundles_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr exo_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr eyes_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr head_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr teeth_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr face_;
    ::game::battlemon::items::OutfitModel* cap_;
    ::game::battlemon::items::OutfitModel* cloth_;
    ::game::battlemon::items::OutfitModel* fire_arm_;
    ::game::battlemon::items::OutfitModel* cold_arm_;
    ::game::battlemon::items::OutfitModel* back_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_items_2eproto;
};
// -------------------------------------------------------------------

class OutfitModel final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:game.battlemon.items.OutfitModel) */ {
 public:
  inline OutfitModel() : OutfitModel(nullptr) {}
  ~OutfitModel() override;
  explicit PROTOBUF_CONSTEXPR OutfitModel(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OutfitModel(const OutfitModel& from);
  OutfitModel(OutfitModel&& from) noexcept
    : OutfitModel() {
    *this = ::std::move(from);
  }

  inline OutfitModel& operator=(const OutfitModel& from) {
    CopyFrom(from);
    return *this;
  }
  inline OutfitModel& operator=(OutfitModel&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OutfitModel& default_instance() {
    return *internal_default_instance();
  }
  static inline const OutfitModel* internal_default_instance() {
    return reinterpret_cast<const OutfitModel*>(
               &_OutfitModel_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(OutfitModel& a, OutfitModel& b) {
    a.Swap(&b);
  }
  inline void Swap(OutfitModel* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OutfitModel* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OutfitModel* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OutfitModel>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OutfitModel& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OutfitModel& from) {
    OutfitModel::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OutfitModel* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "game.battlemon.items.OutfitModel";
  }
  protected:
  explicit OutfitModel(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFlavourFieldNumber = 1,
    kTokenIdFieldNumber = 2,
    kKindFieldNumber = 3,
  };
  // string flavour = 1;
  void clear_flavour();
  const std::string& flavour() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_flavour(ArgT0&& arg0, ArgT... args);
  std::string* mutable_flavour();
  PROTOBUF_NODISCARD std::string* release_flavour();
  void set_allocated_flavour(std::string* flavour);
  private:
  const std::string& _internal_flavour() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_flavour(const std::string& value);
  std::string* _internal_mutable_flavour();
  public:

  // string token_id = 2;
  void clear_token_id();
  const std::string& token_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_token_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_token_id();
  PROTOBUF_NODISCARD std::string* release_token_id();
  void set_allocated_token_id(std::string* token_id);
  private:
  const std::string& _internal_token_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_token_id(const std::string& value);
  std::string* _internal_mutable_token_id();
  public:

  // .game.battlemon.items.OutfitKind kind = 3;
  void clear_kind();
  ::game::battlemon::items::OutfitKind kind() const;
  void set_kind(::game::battlemon::items::OutfitKind value);
  private:
  ::game::battlemon::items::OutfitKind _internal_kind() const;
  void _internal_set_kind(::game::battlemon::items::OutfitKind value);
  public:

  // @@protoc_insertion_point(class_scope:game.battlemon.items.OutfitModel)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr flavour_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr token_id_;
    int kind_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_items_2eproto;
};
// -------------------------------------------------------------------

class WeaponBundle final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:game.battlemon.items.WeaponBundle) */ {
 public:
  inline WeaponBundle() : WeaponBundle(nullptr) {}
  ~WeaponBundle() override;
  explicit PROTOBUF_CONSTEXPR WeaponBundle(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WeaponBundle(const WeaponBundle& from);
  WeaponBundle(WeaponBundle&& from) noexcept
    : WeaponBundle() {
    *this = ::std::move(from);
  }

  inline WeaponBundle& operator=(const WeaponBundle& from) {
    CopyFrom(from);
    return *this;
  }
  inline WeaponBundle& operator=(WeaponBundle&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WeaponBundle& default_instance() {
    return *internal_default_instance();
  }
  static inline const WeaponBundle* internal_default_instance() {
    return reinterpret_cast<const WeaponBundle*>(
               &_WeaponBundle_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(WeaponBundle& a, WeaponBundle& b) {
    a.Swap(&b);
  }
  inline void Swap(WeaponBundle* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WeaponBundle* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WeaponBundle* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WeaponBundle>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WeaponBundle& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const WeaponBundle& from) {
    WeaponBundle::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WeaponBundle* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "game.battlemon.items.WeaponBundle";
  }
  protected:
  explicit WeaponBundle(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 2,
    kTitleFieldNumber = 3,
    kBundleNumFieldNumber = 1,
    kLevelFieldNumber = 4,
  };
  // repeated .game.battlemon.items.WeaponBundleItem items = 2;
  int items_size() const;
  private:
  int _internal_items_size() const;
  public:
  void clear_items();
  ::game::battlemon::items::WeaponBundleItem* mutable_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::game::battlemon::items::WeaponBundleItem >*
      mutable_items();
  private:
  const ::game::battlemon::items::WeaponBundleItem& _internal_items(int index) const;
  ::game::battlemon::items::WeaponBundleItem* _internal_add_items();
  public:
  const ::game::battlemon::items::WeaponBundleItem& items(int index) const;
  ::game::battlemon::items::WeaponBundleItem* add_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::game::battlemon::items::WeaponBundleItem >&
      items() const;

  // string title = 3;
  void clear_title();
  const std::string& title() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_title(ArgT0&& arg0, ArgT... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* title);
  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(const std::string& value);
  std::string* _internal_mutable_title();
  public:

  // int32 bundle_num = 1;
  void clear_bundle_num();
  int32_t bundle_num() const;
  void set_bundle_num(int32_t value);
  private:
  int32_t _internal_bundle_num() const;
  void _internal_set_bundle_num(int32_t value);
  public:

  // int32 level = 4;
  void clear_level();
  int32_t level() const;
  void set_level(int32_t value);
  private:
  int32_t _internal_level() const;
  void _internal_set_level(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:game.battlemon.items.WeaponBundle)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::game::battlemon::items::WeaponBundleItem > items_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
    int32_t bundle_num_;
    int32_t level_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_items_2eproto;
};
// -------------------------------------------------------------------

class WeaponBundleItem final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:game.battlemon.items.WeaponBundleItem) */ {
 public:
  inline WeaponBundleItem() : WeaponBundleItem(nullptr) {}
  ~WeaponBundleItem() override;
  explicit PROTOBUF_CONSTEXPR WeaponBundleItem(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WeaponBundleItem(const WeaponBundleItem& from);
  WeaponBundleItem(WeaponBundleItem&& from) noexcept
    : WeaponBundleItem() {
    *this = ::std::move(from);
  }

  inline WeaponBundleItem& operator=(const WeaponBundleItem& from) {
    CopyFrom(from);
    return *this;
  }
  inline WeaponBundleItem& operator=(WeaponBundleItem&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WeaponBundleItem& default_instance() {
    return *internal_default_instance();
  }
  static inline const WeaponBundleItem* internal_default_instance() {
    return reinterpret_cast<const WeaponBundleItem*>(
               &_WeaponBundleItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(WeaponBundleItem& a, WeaponBundleItem& b) {
    a.Swap(&b);
  }
  inline void Swap(WeaponBundleItem* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WeaponBundleItem* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WeaponBundleItem* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WeaponBundleItem>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WeaponBundleItem& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const WeaponBundleItem& from) {
    WeaponBundleItem::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WeaponBundleItem* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "game.battlemon.items.WeaponBundleItem";
  }
  protected:
  explicit WeaponBundleItem(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSkinFieldNumber = 2,
    kItemTypeFieldNumber = 1,
    kSlotTypeFieldNumber = 3,
  };
  // string skin = 2;
  void clear_skin();
  const std::string& skin() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_skin(ArgT0&& arg0, ArgT... args);
  std::string* mutable_skin();
  PROTOBUF_NODISCARD std::string* release_skin();
  void set_allocated_skin(std::string* skin);
  private:
  const std::string& _internal_skin() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_skin(const std::string& value);
  std::string* _internal_mutable_skin();
  public:

  // .game.battlemon.items.WeaponBundleItemType item_type = 1;
  void clear_item_type();
  ::game::battlemon::items::WeaponBundleItemType item_type() const;
  void set_item_type(::game::battlemon::items::WeaponBundleItemType value);
  private:
  ::game::battlemon::items::WeaponBundleItemType _internal_item_type() const;
  void _internal_set_item_type(::game::battlemon::items::WeaponBundleItemType value);
  public:

  // .game.battlemon.items.WeaponBundleSlotType slot_type = 3;
  void clear_slot_type();
  ::game::battlemon::items::WeaponBundleSlotType slot_type() const;
  void set_slot_type(::game::battlemon::items::WeaponBundleSlotType value);
  private:
  ::game::battlemon::items::WeaponBundleSlotType _internal_slot_type() const;
  void _internal_set_slot_type(::game::battlemon::items::WeaponBundleSlotType value);
  public:

  // @@protoc_insertion_point(class_scope:game.battlemon.items.WeaponBundleItem)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr skin_;
    int item_type_;
    int slot_type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_items_2eproto;
};
// -------------------------------------------------------------------

class GetBundlesRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:game.battlemon.items.GetBundlesRequest) */ {
 public:
  inline GetBundlesRequest() : GetBundlesRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR GetBundlesRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetBundlesRequest(const GetBundlesRequest& from);
  GetBundlesRequest(GetBundlesRequest&& from) noexcept
    : GetBundlesRequest() {
    *this = ::std::move(from);
  }

  inline GetBundlesRequest& operator=(const GetBundlesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetBundlesRequest& operator=(GetBundlesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetBundlesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetBundlesRequest* internal_default_instance() {
    return reinterpret_cast<const GetBundlesRequest*>(
               &_GetBundlesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(GetBundlesRequest& a, GetBundlesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetBundlesRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetBundlesRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetBundlesRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetBundlesRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const GetBundlesRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const GetBundlesRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "game.battlemon.items.GetBundlesRequest";
  }
  protected:
  explicit GetBundlesRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:game.battlemon.items.GetBundlesRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_items_2eproto;
};
// -------------------------------------------------------------------

class GetBundlesResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:game.battlemon.items.GetBundlesResponse) */ {
 public:
  inline GetBundlesResponse() : GetBundlesResponse(nullptr) {}
  ~GetBundlesResponse() override;
  explicit PROTOBUF_CONSTEXPR GetBundlesResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetBundlesResponse(const GetBundlesResponse& from);
  GetBundlesResponse(GetBundlesResponse&& from) noexcept
    : GetBundlesResponse() {
    *this = ::std::move(from);
  }

  inline GetBundlesResponse& operator=(const GetBundlesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetBundlesResponse& operator=(GetBundlesResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetBundlesResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetBundlesResponse* internal_default_instance() {
    return reinterpret_cast<const GetBundlesResponse*>(
               &_GetBundlesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(GetBundlesResponse& a, GetBundlesResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetBundlesResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetBundlesResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetBundlesResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetBundlesResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetBundlesResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetBundlesResponse& from) {
    GetBundlesResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetBundlesResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "game.battlemon.items.GetBundlesResponse";
  }
  protected:
  explicit GetBundlesResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBundlesFieldNumber = 1,
  };
  // repeated .game.battlemon.items.WeaponBundle bundles = 1;
  int bundles_size() const;
  private:
  int _internal_bundles_size() const;
  public:
  void clear_bundles();
  ::game::battlemon::items::WeaponBundle* mutable_bundles(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::game::battlemon::items::WeaponBundle >*
      mutable_bundles();
  private:
  const ::game::battlemon::items::WeaponBundle& _internal_bundles(int index) const;
  ::game::battlemon::items::WeaponBundle* _internal_add_bundles();
  public:
  const ::game::battlemon::items::WeaponBundle& bundles(int index) const;
  ::game::battlemon::items::WeaponBundle* add_bundles();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::game::battlemon::items::WeaponBundle >&
      bundles() const;

  // @@protoc_insertion_point(class_scope:game.battlemon.items.GetBundlesResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::game::battlemon::items::WeaponBundle > bundles_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_items_2eproto;
};
// -------------------------------------------------------------------

class EditBundleRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:game.battlemon.items.EditBundleRequest) */ {
 public:
  inline EditBundleRequest() : EditBundleRequest(nullptr) {}
  ~EditBundleRequest() override;
  explicit PROTOBUF_CONSTEXPR EditBundleRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EditBundleRequest(const EditBundleRequest& from);
  EditBundleRequest(EditBundleRequest&& from) noexcept
    : EditBundleRequest() {
    *this = ::std::move(from);
  }

  inline EditBundleRequest& operator=(const EditBundleRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline EditBundleRequest& operator=(EditBundleRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EditBundleRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const EditBundleRequest* internal_default_instance() {
    return reinterpret_cast<const EditBundleRequest*>(
               &_EditBundleRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(EditBundleRequest& a, EditBundleRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(EditBundleRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EditBundleRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EditBundleRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EditBundleRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EditBundleRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EditBundleRequest& from) {
    EditBundleRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EditBundleRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "game.battlemon.items.EditBundleRequest";
  }
  protected:
  explicit EditBundleRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 2,
    kTitleFieldNumber = 3,
    kBundleNumFieldNumber = 1,
  };
  // repeated .game.battlemon.items.WeaponBundleItem items = 2;
  int items_size() const;
  private:
  int _internal_items_size() const;
  public:
  void clear_items();
  ::game::battlemon::items::WeaponBundleItem* mutable_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::game::battlemon::items::WeaponBundleItem >*
      mutable_items();
  private:
  const ::game::battlemon::items::WeaponBundleItem& _internal_items(int index) const;
  ::game::battlemon::items::WeaponBundleItem* _internal_add_items();
  public:
  const ::game::battlemon::items::WeaponBundleItem& items(int index) const;
  ::game::battlemon::items::WeaponBundleItem* add_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::game::battlemon::items::WeaponBundleItem >&
      items() const;

  // string title = 3;
  void clear_title();
  const std::string& title() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_title(ArgT0&& arg0, ArgT... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* title);
  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(const std::string& value);
  std::string* _internal_mutable_title();
  public:

  // int32 bundle_num = 1;
  void clear_bundle_num();
  int32_t bundle_num() const;
  void set_bundle_num(int32_t value);
  private:
  int32_t _internal_bundle_num() const;
  void _internal_set_bundle_num(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:game.battlemon.items.EditBundleRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::game::battlemon::items::WeaponBundleItem > items_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
    int32_t bundle_num_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_items_2eproto;
};
// -------------------------------------------------------------------

class AttachBundleRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:game.battlemon.items.AttachBundleRequest) */ {
 public:
  inline AttachBundleRequest() : AttachBundleRequest(nullptr) {}
  ~AttachBundleRequest() override;
  explicit PROTOBUF_CONSTEXPR AttachBundleRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AttachBundleRequest(const AttachBundleRequest& from);
  AttachBundleRequest(AttachBundleRequest&& from) noexcept
    : AttachBundleRequest() {
    *this = ::std::move(from);
  }

  inline AttachBundleRequest& operator=(const AttachBundleRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AttachBundleRequest& operator=(AttachBundleRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AttachBundleRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const AttachBundleRequest* internal_default_instance() {
    return reinterpret_cast<const AttachBundleRequest*>(
               &_AttachBundleRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(AttachBundleRequest& a, AttachBundleRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AttachBundleRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AttachBundleRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AttachBundleRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AttachBundleRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AttachBundleRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AttachBundleRequest& from) {
    AttachBundleRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AttachBundleRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "game.battlemon.items.AttachBundleRequest";
  }
  protected:
  explicit AttachBundleRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLemonIdFieldNumber = 2,
    kBundleNumFieldNumber = 1,
  };
  // string lemon_id = 2;
  void clear_lemon_id();
  const std::string& lemon_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_lemon_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_lemon_id();
  PROTOBUF_NODISCARD std::string* release_lemon_id();
  void set_allocated_lemon_id(std::string* lemon_id);
  private:
  const std::string& _internal_lemon_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_lemon_id(const std::string& value);
  std::string* _internal_mutable_lemon_id();
  public:

  // int32 bundle_num = 1;
  void clear_bundle_num();
  int32_t bundle_num() const;
  void set_bundle_num(int32_t value);
  private:
  int32_t _internal_bundle_num() const;
  void _internal_set_bundle_num(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:game.battlemon.items.AttachBundleRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr lemon_id_;
    int32_t bundle_num_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_items_2eproto;
};
// -------------------------------------------------------------------

class DetachBundleRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:game.battlemon.items.DetachBundleRequest) */ {
 public:
  inline DetachBundleRequest() : DetachBundleRequest(nullptr) {}
  ~DetachBundleRequest() override;
  explicit PROTOBUF_CONSTEXPR DetachBundleRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DetachBundleRequest(const DetachBundleRequest& from);
  DetachBundleRequest(DetachBundleRequest&& from) noexcept
    : DetachBundleRequest() {
    *this = ::std::move(from);
  }

  inline DetachBundleRequest& operator=(const DetachBundleRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DetachBundleRequest& operator=(DetachBundleRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DetachBundleRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DetachBundleRequest* internal_default_instance() {
    return reinterpret_cast<const DetachBundleRequest*>(
               &_DetachBundleRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(DetachBundleRequest& a, DetachBundleRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DetachBundleRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DetachBundleRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DetachBundleRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DetachBundleRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DetachBundleRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DetachBundleRequest& from) {
    DetachBundleRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DetachBundleRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "game.battlemon.items.DetachBundleRequest";
  }
  protected:
  explicit DetachBundleRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLemonIdFieldNumber = 2,
    kBundleNumFieldNumber = 1,
  };
  // string lemon_id = 2;
  void clear_lemon_id();
  const std::string& lemon_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_lemon_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_lemon_id();
  PROTOBUF_NODISCARD std::string* release_lemon_id();
  void set_allocated_lemon_id(std::string* lemon_id);
  private:
  const std::string& _internal_lemon_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_lemon_id(const std::string& value);
  std::string* _internal_mutable_lemon_id();
  public:

  // int32 bundle_num = 1;
  void clear_bundle_num();
  int32_t bundle_num() const;
  void set_bundle_num(int32_t value);
  private:
  int32_t _internal_bundle_num() const;
  void _internal_set_bundle_num(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:game.battlemon.items.DetachBundleRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr lemon_id_;
    int32_t bundle_num_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_items_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ItemsRequest

// -------------------------------------------------------------------

// ItemsResponse

// repeated .game.battlemon.items.Item items = 1;
inline int ItemsResponse::_internal_items_size() const {
  return _impl_.items_.size();
}
inline int ItemsResponse::items_size() const {
  return _internal_items_size();
}
inline void ItemsResponse::clear_items() {
  _impl_.items_.Clear();
}
inline ::game::battlemon::items::Item* ItemsResponse::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:game.battlemon.items.ItemsResponse.items)
  return _impl_.items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::game::battlemon::items::Item >*
ItemsResponse::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:game.battlemon.items.ItemsResponse.items)
  return &_impl_.items_;
}
inline const ::game::battlemon::items::Item& ItemsResponse::_internal_items(int index) const {
  return _impl_.items_.Get(index);
}
inline const ::game::battlemon::items::Item& ItemsResponse::items(int index) const {
  // @@protoc_insertion_point(field_get:game.battlemon.items.ItemsResponse.items)
  return _internal_items(index);
}
inline ::game::battlemon::items::Item* ItemsResponse::_internal_add_items() {
  return _impl_.items_.Add();
}
inline ::game::battlemon::items::Item* ItemsResponse::add_items() {
  ::game::battlemon::items::Item* _add = _internal_add_items();
  // @@protoc_insertion_point(field_add:game.battlemon.items.ItemsResponse.items)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::game::battlemon::items::Item >&
ItemsResponse::items() const {
  // @@protoc_insertion_point(field_list:game.battlemon.items.ItemsResponse.items)
  return _impl_.items_;
}

// -------------------------------------------------------------------

// Item

// string token_id = 1;
inline void Item::clear_token_id() {
  _impl_.token_id_.ClearToEmpty();
}
inline const std::string& Item::token_id() const {
  // @@protoc_insertion_point(field_get:game.battlemon.items.Item.token_id)
  return _internal_token_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Item::set_token_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.token_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:game.battlemon.items.Item.token_id)
}
inline std::string* Item::mutable_token_id() {
  std::string* _s = _internal_mutable_token_id();
  // @@protoc_insertion_point(field_mutable:game.battlemon.items.Item.token_id)
  return _s;
}
inline const std::string& Item::_internal_token_id() const {
  return _impl_.token_id_.Get();
}
inline void Item::_internal_set_token_id(const std::string& value) {
  
  _impl_.token_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Item::_internal_mutable_token_id() {
  
  return _impl_.token_id_.Mutable(GetArenaForAllocation());
}
inline std::string* Item::release_token_id() {
  // @@protoc_insertion_point(field_release:game.battlemon.items.Item.token_id)
  return _impl_.token_id_.Release();
}
inline void Item::set_allocated_token_id(std::string* token_id) {
  if (token_id != nullptr) {
    
  } else {
    
  }
  _impl_.token_id_.SetAllocated(token_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.token_id_.IsDefault()) {
    _impl_.token_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:game.battlemon.items.Item.token_id)
}

// string media = 2;
inline void Item::clear_media() {
  _impl_.media_.ClearToEmpty();
}
inline const std::string& Item::media() const {
  // @@protoc_insertion_point(field_get:game.battlemon.items.Item.media)
  return _internal_media();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Item::set_media(ArgT0&& arg0, ArgT... args) {
 
 _impl_.media_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:game.battlemon.items.Item.media)
}
inline std::string* Item::mutable_media() {
  std::string* _s = _internal_mutable_media();
  // @@protoc_insertion_point(field_mutable:game.battlemon.items.Item.media)
  return _s;
}
inline const std::string& Item::_internal_media() const {
  return _impl_.media_.Get();
}
inline void Item::_internal_set_media(const std::string& value) {
  
  _impl_.media_.Set(value, GetArenaForAllocation());
}
inline std::string* Item::_internal_mutable_media() {
  
  return _impl_.media_.Mutable(GetArenaForAllocation());
}
inline std::string* Item::release_media() {
  // @@protoc_insertion_point(field_release:game.battlemon.items.Item.media)
  return _impl_.media_.Release();
}
inline void Item::set_allocated_media(std::string* media) {
  if (media != nullptr) {
    
  } else {
    
  }
  _impl_.media_.SetAllocated(media, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.media_.IsDefault()) {
    _impl_.media_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:game.battlemon.items.Item.media)
}

// string owner_id = 3;
inline void Item::clear_owner_id() {
  _impl_.owner_id_.ClearToEmpty();
}
inline const std::string& Item::owner_id() const {
  // @@protoc_insertion_point(field_get:game.battlemon.items.Item.owner_id)
  return _internal_owner_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Item::set_owner_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.owner_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:game.battlemon.items.Item.owner_id)
}
inline std::string* Item::mutable_owner_id() {
  std::string* _s = _internal_mutable_owner_id();
  // @@protoc_insertion_point(field_mutable:game.battlemon.items.Item.owner_id)
  return _s;
}
inline const std::string& Item::_internal_owner_id() const {
  return _impl_.owner_id_.Get();
}
inline void Item::_internal_set_owner_id(const std::string& value) {
  
  _impl_.owner_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Item::_internal_mutable_owner_id() {
  
  return _impl_.owner_id_.Mutable(GetArenaForAllocation());
}
inline std::string* Item::release_owner_id() {
  // @@protoc_insertion_point(field_release:game.battlemon.items.Item.owner_id)
  return _impl_.owner_id_.Release();
}
inline void Item::set_allocated_owner_id(std::string* owner_id) {
  if (owner_id != nullptr) {
    
  } else {
    
  }
  _impl_.owner_id_.SetAllocated(owner_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.owner_id_.IsDefault()) {
    _impl_.owner_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:game.battlemon.items.Item.owner_id)
}

// bool in_fight = 4;
inline void Item::clear_in_fight() {
  _impl_.in_fight_ = false;
}
inline bool Item::_internal_in_fight() const {
  return _impl_.in_fight_;
}
inline bool Item::in_fight() const {
  // @@protoc_insertion_point(field_get:game.battlemon.items.Item.in_fight)
  return _internal_in_fight();
}
inline void Item::_internal_set_in_fight(bool value) {
  
  _impl_.in_fight_ = value;
}
inline void Item::set_in_fight(bool value) {
  _internal_set_in_fight(value);
  // @@protoc_insertion_point(field_set:game.battlemon.items.Item.in_fight)
}

// .game.battlemon.items.LemonModel lemon = 5;
inline bool Item::_internal_has_lemon() const {
  return model_case() == kLemon;
}
inline bool Item::has_lemon() const {
  return _internal_has_lemon();
}
inline void Item::set_has_lemon() {
  _impl_._oneof_case_[0] = kLemon;
}
inline void Item::clear_lemon() {
  if (_internal_has_lemon()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.model_.lemon_;
    }
    clear_has_model();
  }
}
inline ::game::battlemon::items::LemonModel* Item::release_lemon() {
  // @@protoc_insertion_point(field_release:game.battlemon.items.Item.lemon)
  if (_internal_has_lemon()) {
    clear_has_model();
    ::game::battlemon::items::LemonModel* temp = _impl_.model_.lemon_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.model_.lemon_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::game::battlemon::items::LemonModel& Item::_internal_lemon() const {
  return _internal_has_lemon()
      ? *_impl_.model_.lemon_
      : reinterpret_cast< ::game::battlemon::items::LemonModel&>(::game::battlemon::items::_LemonModel_default_instance_);
}
inline const ::game::battlemon::items::LemonModel& Item::lemon() const {
  // @@protoc_insertion_point(field_get:game.battlemon.items.Item.lemon)
  return _internal_lemon();
}
inline ::game::battlemon::items::LemonModel* Item::unsafe_arena_release_lemon() {
  // @@protoc_insertion_point(field_unsafe_arena_release:game.battlemon.items.Item.lemon)
  if (_internal_has_lemon()) {
    clear_has_model();
    ::game::battlemon::items::LemonModel* temp = _impl_.model_.lemon_;
    _impl_.model_.lemon_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Item::unsafe_arena_set_allocated_lemon(::game::battlemon::items::LemonModel* lemon) {
  clear_model();
  if (lemon) {
    set_has_lemon();
    _impl_.model_.lemon_ = lemon;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:game.battlemon.items.Item.lemon)
}
inline ::game::battlemon::items::LemonModel* Item::_internal_mutable_lemon() {
  if (!_internal_has_lemon()) {
    clear_model();
    set_has_lemon();
    _impl_.model_.lemon_ = CreateMaybeMessage< ::game::battlemon::items::LemonModel >(GetArenaForAllocation());
  }
  return _impl_.model_.lemon_;
}
inline ::game::battlemon::items::LemonModel* Item::mutable_lemon() {
  ::game::battlemon::items::LemonModel* _msg = _internal_mutable_lemon();
  // @@protoc_insertion_point(field_mutable:game.battlemon.items.Item.lemon)
  return _msg;
}

// .game.battlemon.items.OutfitModel outfit = 6;
inline bool Item::_internal_has_outfit() const {
  return model_case() == kOutfit;
}
inline bool Item::has_outfit() const {
  return _internal_has_outfit();
}
inline void Item::set_has_outfit() {
  _impl_._oneof_case_[0] = kOutfit;
}
inline void Item::clear_outfit() {
  if (_internal_has_outfit()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.model_.outfit_;
    }
    clear_has_model();
  }
}
inline ::game::battlemon::items::OutfitModel* Item::release_outfit() {
  // @@protoc_insertion_point(field_release:game.battlemon.items.Item.outfit)
  if (_internal_has_outfit()) {
    clear_has_model();
    ::game::battlemon::items::OutfitModel* temp = _impl_.model_.outfit_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.model_.outfit_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::game::battlemon::items::OutfitModel& Item::_internal_outfit() const {
  return _internal_has_outfit()
      ? *_impl_.model_.outfit_
      : reinterpret_cast< ::game::battlemon::items::OutfitModel&>(::game::battlemon::items::_OutfitModel_default_instance_);
}
inline const ::game::battlemon::items::OutfitModel& Item::outfit() const {
  // @@protoc_insertion_point(field_get:game.battlemon.items.Item.outfit)
  return _internal_outfit();
}
inline ::game::battlemon::items::OutfitModel* Item::unsafe_arena_release_outfit() {
  // @@protoc_insertion_point(field_unsafe_arena_release:game.battlemon.items.Item.outfit)
  if (_internal_has_outfit()) {
    clear_has_model();
    ::game::battlemon::items::OutfitModel* temp = _impl_.model_.outfit_;
    _impl_.model_.outfit_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Item::unsafe_arena_set_allocated_outfit(::game::battlemon::items::OutfitModel* outfit) {
  clear_model();
  if (outfit) {
    set_has_outfit();
    _impl_.model_.outfit_ = outfit;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:game.battlemon.items.Item.outfit)
}
inline ::game::battlemon::items::OutfitModel* Item::_internal_mutable_outfit() {
  if (!_internal_has_outfit()) {
    clear_model();
    set_has_outfit();
    _impl_.model_.outfit_ = CreateMaybeMessage< ::game::battlemon::items::OutfitModel >(GetArenaForAllocation());
  }
  return _impl_.model_.outfit_;
}
inline ::game::battlemon::items::OutfitModel* Item::mutable_outfit() {
  ::game::battlemon::items::OutfitModel* _msg = _internal_mutable_outfit();
  // @@protoc_insertion_point(field_mutable:game.battlemon.items.Item.outfit)
  return _msg;
}

inline bool Item::has_model() const {
  return model_case() != MODEL_NOT_SET;
}
inline void Item::clear_has_model() {
  _impl_._oneof_case_[0] = MODEL_NOT_SET;
}
inline Item::ModelCase Item::model_case() const {
  return Item::ModelCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// LemonModel

// .game.battlemon.items.OutfitModel cap = 1;
inline bool LemonModel::_internal_has_cap() const {
  return this != internal_default_instance() && _impl_.cap_ != nullptr;
}
inline bool LemonModel::has_cap() const {
  return _internal_has_cap();
}
inline void LemonModel::clear_cap() {
  if (GetArenaForAllocation() == nullptr && _impl_.cap_ != nullptr) {
    delete _impl_.cap_;
  }
  _impl_.cap_ = nullptr;
}
inline const ::game::battlemon::items::OutfitModel& LemonModel::_internal_cap() const {
  const ::game::battlemon::items::OutfitModel* p = _impl_.cap_;
  return p != nullptr ? *p : reinterpret_cast<const ::game::battlemon::items::OutfitModel&>(
      ::game::battlemon::items::_OutfitModel_default_instance_);
}
inline const ::game::battlemon::items::OutfitModel& LemonModel::cap() const {
  // @@protoc_insertion_point(field_get:game.battlemon.items.LemonModel.cap)
  return _internal_cap();
}
inline void LemonModel::unsafe_arena_set_allocated_cap(
    ::game::battlemon::items::OutfitModel* cap) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.cap_);
  }
  _impl_.cap_ = cap;
  if (cap) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:game.battlemon.items.LemonModel.cap)
}
inline ::game::battlemon::items::OutfitModel* LemonModel::release_cap() {
  
  ::game::battlemon::items::OutfitModel* temp = _impl_.cap_;
  _impl_.cap_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::game::battlemon::items::OutfitModel* LemonModel::unsafe_arena_release_cap() {
  // @@protoc_insertion_point(field_release:game.battlemon.items.LemonModel.cap)
  
  ::game::battlemon::items::OutfitModel* temp = _impl_.cap_;
  _impl_.cap_ = nullptr;
  return temp;
}
inline ::game::battlemon::items::OutfitModel* LemonModel::_internal_mutable_cap() {
  
  if (_impl_.cap_ == nullptr) {
    auto* p = CreateMaybeMessage<::game::battlemon::items::OutfitModel>(GetArenaForAllocation());
    _impl_.cap_ = p;
  }
  return _impl_.cap_;
}
inline ::game::battlemon::items::OutfitModel* LemonModel::mutable_cap() {
  ::game::battlemon::items::OutfitModel* _msg = _internal_mutable_cap();
  // @@protoc_insertion_point(field_mutable:game.battlemon.items.LemonModel.cap)
  return _msg;
}
inline void LemonModel::set_allocated_cap(::game::battlemon::items::OutfitModel* cap) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.cap_;
  }
  if (cap) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(cap);
    if (message_arena != submessage_arena) {
      cap = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cap, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.cap_ = cap;
  // @@protoc_insertion_point(field_set_allocated:game.battlemon.items.LemonModel.cap)
}

// .game.battlemon.items.OutfitModel cloth = 2;
inline bool LemonModel::_internal_has_cloth() const {
  return this != internal_default_instance() && _impl_.cloth_ != nullptr;
}
inline bool LemonModel::has_cloth() const {
  return _internal_has_cloth();
}
inline void LemonModel::clear_cloth() {
  if (GetArenaForAllocation() == nullptr && _impl_.cloth_ != nullptr) {
    delete _impl_.cloth_;
  }
  _impl_.cloth_ = nullptr;
}
inline const ::game::battlemon::items::OutfitModel& LemonModel::_internal_cloth() const {
  const ::game::battlemon::items::OutfitModel* p = _impl_.cloth_;
  return p != nullptr ? *p : reinterpret_cast<const ::game::battlemon::items::OutfitModel&>(
      ::game::battlemon::items::_OutfitModel_default_instance_);
}
inline const ::game::battlemon::items::OutfitModel& LemonModel::cloth() const {
  // @@protoc_insertion_point(field_get:game.battlemon.items.LemonModel.cloth)
  return _internal_cloth();
}
inline void LemonModel::unsafe_arena_set_allocated_cloth(
    ::game::battlemon::items::OutfitModel* cloth) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.cloth_);
  }
  _impl_.cloth_ = cloth;
  if (cloth) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:game.battlemon.items.LemonModel.cloth)
}
inline ::game::battlemon::items::OutfitModel* LemonModel::release_cloth() {
  
  ::game::battlemon::items::OutfitModel* temp = _impl_.cloth_;
  _impl_.cloth_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::game::battlemon::items::OutfitModel* LemonModel::unsafe_arena_release_cloth() {
  // @@protoc_insertion_point(field_release:game.battlemon.items.LemonModel.cloth)
  
  ::game::battlemon::items::OutfitModel* temp = _impl_.cloth_;
  _impl_.cloth_ = nullptr;
  return temp;
}
inline ::game::battlemon::items::OutfitModel* LemonModel::_internal_mutable_cloth() {
  
  if (_impl_.cloth_ == nullptr) {
    auto* p = CreateMaybeMessage<::game::battlemon::items::OutfitModel>(GetArenaForAllocation());
    _impl_.cloth_ = p;
  }
  return _impl_.cloth_;
}
inline ::game::battlemon::items::OutfitModel* LemonModel::mutable_cloth() {
  ::game::battlemon::items::OutfitModel* _msg = _internal_mutable_cloth();
  // @@protoc_insertion_point(field_mutable:game.battlemon.items.LemonModel.cloth)
  return _msg;
}
inline void LemonModel::set_allocated_cloth(::game::battlemon::items::OutfitModel* cloth) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.cloth_;
  }
  if (cloth) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(cloth);
    if (message_arena != submessage_arena) {
      cloth = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cloth, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.cloth_ = cloth;
  // @@protoc_insertion_point(field_set_allocated:game.battlemon.items.LemonModel.cloth)
}

// string exo = 3;
inline void LemonModel::clear_exo() {
  _impl_.exo_.ClearToEmpty();
}
inline const std::string& LemonModel::exo() const {
  // @@protoc_insertion_point(field_get:game.battlemon.items.LemonModel.exo)
  return _internal_exo();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LemonModel::set_exo(ArgT0&& arg0, ArgT... args) {
 
 _impl_.exo_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:game.battlemon.items.LemonModel.exo)
}
inline std::string* LemonModel::mutable_exo() {
  std::string* _s = _internal_mutable_exo();
  // @@protoc_insertion_point(field_mutable:game.battlemon.items.LemonModel.exo)
  return _s;
}
inline const std::string& LemonModel::_internal_exo() const {
  return _impl_.exo_.Get();
}
inline void LemonModel::_internal_set_exo(const std::string& value) {
  
  _impl_.exo_.Set(value, GetArenaForAllocation());
}
inline std::string* LemonModel::_internal_mutable_exo() {
  
  return _impl_.exo_.Mutable(GetArenaForAllocation());
}
inline std::string* LemonModel::release_exo() {
  // @@protoc_insertion_point(field_release:game.battlemon.items.LemonModel.exo)
  return _impl_.exo_.Release();
}
inline void LemonModel::set_allocated_exo(std::string* exo) {
  if (exo != nullptr) {
    
  } else {
    
  }
  _impl_.exo_.SetAllocated(exo, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.exo_.IsDefault()) {
    _impl_.exo_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:game.battlemon.items.LemonModel.exo)
}

// string eyes = 4;
inline void LemonModel::clear_eyes() {
  _impl_.eyes_.ClearToEmpty();
}
inline const std::string& LemonModel::eyes() const {
  // @@protoc_insertion_point(field_get:game.battlemon.items.LemonModel.eyes)
  return _internal_eyes();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LemonModel::set_eyes(ArgT0&& arg0, ArgT... args) {
 
 _impl_.eyes_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:game.battlemon.items.LemonModel.eyes)
}
inline std::string* LemonModel::mutable_eyes() {
  std::string* _s = _internal_mutable_eyes();
  // @@protoc_insertion_point(field_mutable:game.battlemon.items.LemonModel.eyes)
  return _s;
}
inline const std::string& LemonModel::_internal_eyes() const {
  return _impl_.eyes_.Get();
}
inline void LemonModel::_internal_set_eyes(const std::string& value) {
  
  _impl_.eyes_.Set(value, GetArenaForAllocation());
}
inline std::string* LemonModel::_internal_mutable_eyes() {
  
  return _impl_.eyes_.Mutable(GetArenaForAllocation());
}
inline std::string* LemonModel::release_eyes() {
  // @@protoc_insertion_point(field_release:game.battlemon.items.LemonModel.eyes)
  return _impl_.eyes_.Release();
}
inline void LemonModel::set_allocated_eyes(std::string* eyes) {
  if (eyes != nullptr) {
    
  } else {
    
  }
  _impl_.eyes_.SetAllocated(eyes, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.eyes_.IsDefault()) {
    _impl_.eyes_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:game.battlemon.items.LemonModel.eyes)
}

// string head = 5;
inline void LemonModel::clear_head() {
  _impl_.head_.ClearToEmpty();
}
inline const std::string& LemonModel::head() const {
  // @@protoc_insertion_point(field_get:game.battlemon.items.LemonModel.head)
  return _internal_head();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LemonModel::set_head(ArgT0&& arg0, ArgT... args) {
 
 _impl_.head_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:game.battlemon.items.LemonModel.head)
}
inline std::string* LemonModel::mutable_head() {
  std::string* _s = _internal_mutable_head();
  // @@protoc_insertion_point(field_mutable:game.battlemon.items.LemonModel.head)
  return _s;
}
inline const std::string& LemonModel::_internal_head() const {
  return _impl_.head_.Get();
}
inline void LemonModel::_internal_set_head(const std::string& value) {
  
  _impl_.head_.Set(value, GetArenaForAllocation());
}
inline std::string* LemonModel::_internal_mutable_head() {
  
  return _impl_.head_.Mutable(GetArenaForAllocation());
}
inline std::string* LemonModel::release_head() {
  // @@protoc_insertion_point(field_release:game.battlemon.items.LemonModel.head)
  return _impl_.head_.Release();
}
inline void LemonModel::set_allocated_head(std::string* head) {
  if (head != nullptr) {
    
  } else {
    
  }
  _impl_.head_.SetAllocated(head, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.head_.IsDefault()) {
    _impl_.head_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:game.battlemon.items.LemonModel.head)
}

// string teeth = 6;
inline void LemonModel::clear_teeth() {
  _impl_.teeth_.ClearToEmpty();
}
inline const std::string& LemonModel::teeth() const {
  // @@protoc_insertion_point(field_get:game.battlemon.items.LemonModel.teeth)
  return _internal_teeth();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LemonModel::set_teeth(ArgT0&& arg0, ArgT... args) {
 
 _impl_.teeth_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:game.battlemon.items.LemonModel.teeth)
}
inline std::string* LemonModel::mutable_teeth() {
  std::string* _s = _internal_mutable_teeth();
  // @@protoc_insertion_point(field_mutable:game.battlemon.items.LemonModel.teeth)
  return _s;
}
inline const std::string& LemonModel::_internal_teeth() const {
  return _impl_.teeth_.Get();
}
inline void LemonModel::_internal_set_teeth(const std::string& value) {
  
  _impl_.teeth_.Set(value, GetArenaForAllocation());
}
inline std::string* LemonModel::_internal_mutable_teeth() {
  
  return _impl_.teeth_.Mutable(GetArenaForAllocation());
}
inline std::string* LemonModel::release_teeth() {
  // @@protoc_insertion_point(field_release:game.battlemon.items.LemonModel.teeth)
  return _impl_.teeth_.Release();
}
inline void LemonModel::set_allocated_teeth(std::string* teeth) {
  if (teeth != nullptr) {
    
  } else {
    
  }
  _impl_.teeth_.SetAllocated(teeth, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.teeth_.IsDefault()) {
    _impl_.teeth_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:game.battlemon.items.LemonModel.teeth)
}

// string face = 7;
inline void LemonModel::clear_face() {
  _impl_.face_.ClearToEmpty();
}
inline const std::string& LemonModel::face() const {
  // @@protoc_insertion_point(field_get:game.battlemon.items.LemonModel.face)
  return _internal_face();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LemonModel::set_face(ArgT0&& arg0, ArgT... args) {
 
 _impl_.face_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:game.battlemon.items.LemonModel.face)
}
inline std::string* LemonModel::mutable_face() {
  std::string* _s = _internal_mutable_face();
  // @@protoc_insertion_point(field_mutable:game.battlemon.items.LemonModel.face)
  return _s;
}
inline const std::string& LemonModel::_internal_face() const {
  return _impl_.face_.Get();
}
inline void LemonModel::_internal_set_face(const std::string& value) {
  
  _impl_.face_.Set(value, GetArenaForAllocation());
}
inline std::string* LemonModel::_internal_mutable_face() {
  
  return _impl_.face_.Mutable(GetArenaForAllocation());
}
inline std::string* LemonModel::release_face() {
  // @@protoc_insertion_point(field_release:game.battlemon.items.LemonModel.face)
  return _impl_.face_.Release();
}
inline void LemonModel::set_allocated_face(std::string* face) {
  if (face != nullptr) {
    
  } else {
    
  }
  _impl_.face_.SetAllocated(face, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.face_.IsDefault()) {
    _impl_.face_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:game.battlemon.items.LemonModel.face)
}

// .game.battlemon.items.OutfitModel fire_arm = 8;
inline bool LemonModel::_internal_has_fire_arm() const {
  return this != internal_default_instance() && _impl_.fire_arm_ != nullptr;
}
inline bool LemonModel::has_fire_arm() const {
  return _internal_has_fire_arm();
}
inline void LemonModel::clear_fire_arm() {
  if (GetArenaForAllocation() == nullptr && _impl_.fire_arm_ != nullptr) {
    delete _impl_.fire_arm_;
  }
  _impl_.fire_arm_ = nullptr;
}
inline const ::game::battlemon::items::OutfitModel& LemonModel::_internal_fire_arm() const {
  const ::game::battlemon::items::OutfitModel* p = _impl_.fire_arm_;
  return p != nullptr ? *p : reinterpret_cast<const ::game::battlemon::items::OutfitModel&>(
      ::game::battlemon::items::_OutfitModel_default_instance_);
}
inline const ::game::battlemon::items::OutfitModel& LemonModel::fire_arm() const {
  // @@protoc_insertion_point(field_get:game.battlemon.items.LemonModel.fire_arm)
  return _internal_fire_arm();
}
inline void LemonModel::unsafe_arena_set_allocated_fire_arm(
    ::game::battlemon::items::OutfitModel* fire_arm) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.fire_arm_);
  }
  _impl_.fire_arm_ = fire_arm;
  if (fire_arm) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:game.battlemon.items.LemonModel.fire_arm)
}
inline ::game::battlemon::items::OutfitModel* LemonModel::release_fire_arm() {
  
  ::game::battlemon::items::OutfitModel* temp = _impl_.fire_arm_;
  _impl_.fire_arm_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::game::battlemon::items::OutfitModel* LemonModel::unsafe_arena_release_fire_arm() {
  // @@protoc_insertion_point(field_release:game.battlemon.items.LemonModel.fire_arm)
  
  ::game::battlemon::items::OutfitModel* temp = _impl_.fire_arm_;
  _impl_.fire_arm_ = nullptr;
  return temp;
}
inline ::game::battlemon::items::OutfitModel* LemonModel::_internal_mutable_fire_arm() {
  
  if (_impl_.fire_arm_ == nullptr) {
    auto* p = CreateMaybeMessage<::game::battlemon::items::OutfitModel>(GetArenaForAllocation());
    _impl_.fire_arm_ = p;
  }
  return _impl_.fire_arm_;
}
inline ::game::battlemon::items::OutfitModel* LemonModel::mutable_fire_arm() {
  ::game::battlemon::items::OutfitModel* _msg = _internal_mutable_fire_arm();
  // @@protoc_insertion_point(field_mutable:game.battlemon.items.LemonModel.fire_arm)
  return _msg;
}
inline void LemonModel::set_allocated_fire_arm(::game::battlemon::items::OutfitModel* fire_arm) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.fire_arm_;
  }
  if (fire_arm) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(fire_arm);
    if (message_arena != submessage_arena) {
      fire_arm = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, fire_arm, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.fire_arm_ = fire_arm;
  // @@protoc_insertion_point(field_set_allocated:game.battlemon.items.LemonModel.fire_arm)
}

// .game.battlemon.items.OutfitModel cold_arm = 9;
inline bool LemonModel::_internal_has_cold_arm() const {
  return this != internal_default_instance() && _impl_.cold_arm_ != nullptr;
}
inline bool LemonModel::has_cold_arm() const {
  return _internal_has_cold_arm();
}
inline void LemonModel::clear_cold_arm() {
  if (GetArenaForAllocation() == nullptr && _impl_.cold_arm_ != nullptr) {
    delete _impl_.cold_arm_;
  }
  _impl_.cold_arm_ = nullptr;
}
inline const ::game::battlemon::items::OutfitModel& LemonModel::_internal_cold_arm() const {
  const ::game::battlemon::items::OutfitModel* p = _impl_.cold_arm_;
  return p != nullptr ? *p : reinterpret_cast<const ::game::battlemon::items::OutfitModel&>(
      ::game::battlemon::items::_OutfitModel_default_instance_);
}
inline const ::game::battlemon::items::OutfitModel& LemonModel::cold_arm() const {
  // @@protoc_insertion_point(field_get:game.battlemon.items.LemonModel.cold_arm)
  return _internal_cold_arm();
}
inline void LemonModel::unsafe_arena_set_allocated_cold_arm(
    ::game::battlemon::items::OutfitModel* cold_arm) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.cold_arm_);
  }
  _impl_.cold_arm_ = cold_arm;
  if (cold_arm) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:game.battlemon.items.LemonModel.cold_arm)
}
inline ::game::battlemon::items::OutfitModel* LemonModel::release_cold_arm() {
  
  ::game::battlemon::items::OutfitModel* temp = _impl_.cold_arm_;
  _impl_.cold_arm_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::game::battlemon::items::OutfitModel* LemonModel::unsafe_arena_release_cold_arm() {
  // @@protoc_insertion_point(field_release:game.battlemon.items.LemonModel.cold_arm)
  
  ::game::battlemon::items::OutfitModel* temp = _impl_.cold_arm_;
  _impl_.cold_arm_ = nullptr;
  return temp;
}
inline ::game::battlemon::items::OutfitModel* LemonModel::_internal_mutable_cold_arm() {
  
  if (_impl_.cold_arm_ == nullptr) {
    auto* p = CreateMaybeMessage<::game::battlemon::items::OutfitModel>(GetArenaForAllocation());
    _impl_.cold_arm_ = p;
  }
  return _impl_.cold_arm_;
}
inline ::game::battlemon::items::OutfitModel* LemonModel::mutable_cold_arm() {
  ::game::battlemon::items::OutfitModel* _msg = _internal_mutable_cold_arm();
  // @@protoc_insertion_point(field_mutable:game.battlemon.items.LemonModel.cold_arm)
  return _msg;
}
inline void LemonModel::set_allocated_cold_arm(::game::battlemon::items::OutfitModel* cold_arm) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.cold_arm_;
  }
  if (cold_arm) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(cold_arm);
    if (message_arena != submessage_arena) {
      cold_arm = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cold_arm, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.cold_arm_ = cold_arm;
  // @@protoc_insertion_point(field_set_allocated:game.battlemon.items.LemonModel.cold_arm)
}

// .game.battlemon.items.OutfitModel back = 10;
inline bool LemonModel::_internal_has_back() const {
  return this != internal_default_instance() && _impl_.back_ != nullptr;
}
inline bool LemonModel::has_back() const {
  return _internal_has_back();
}
inline void LemonModel::clear_back() {
  if (GetArenaForAllocation() == nullptr && _impl_.back_ != nullptr) {
    delete _impl_.back_;
  }
  _impl_.back_ = nullptr;
}
inline const ::game::battlemon::items::OutfitModel& LemonModel::_internal_back() const {
  const ::game::battlemon::items::OutfitModel* p = _impl_.back_;
  return p != nullptr ? *p : reinterpret_cast<const ::game::battlemon::items::OutfitModel&>(
      ::game::battlemon::items::_OutfitModel_default_instance_);
}
inline const ::game::battlemon::items::OutfitModel& LemonModel::back() const {
  // @@protoc_insertion_point(field_get:game.battlemon.items.LemonModel.back)
  return _internal_back();
}
inline void LemonModel::unsafe_arena_set_allocated_back(
    ::game::battlemon::items::OutfitModel* back) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.back_);
  }
  _impl_.back_ = back;
  if (back) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:game.battlemon.items.LemonModel.back)
}
inline ::game::battlemon::items::OutfitModel* LemonModel::release_back() {
  
  ::game::battlemon::items::OutfitModel* temp = _impl_.back_;
  _impl_.back_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::game::battlemon::items::OutfitModel* LemonModel::unsafe_arena_release_back() {
  // @@protoc_insertion_point(field_release:game.battlemon.items.LemonModel.back)
  
  ::game::battlemon::items::OutfitModel* temp = _impl_.back_;
  _impl_.back_ = nullptr;
  return temp;
}
inline ::game::battlemon::items::OutfitModel* LemonModel::_internal_mutable_back() {
  
  if (_impl_.back_ == nullptr) {
    auto* p = CreateMaybeMessage<::game::battlemon::items::OutfitModel>(GetArenaForAllocation());
    _impl_.back_ = p;
  }
  return _impl_.back_;
}
inline ::game::battlemon::items::OutfitModel* LemonModel::mutable_back() {
  ::game::battlemon::items::OutfitModel* _msg = _internal_mutable_back();
  // @@protoc_insertion_point(field_mutable:game.battlemon.items.LemonModel.back)
  return _msg;
}
inline void LemonModel::set_allocated_back(::game::battlemon::items::OutfitModel* back) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.back_;
  }
  if (back) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(back);
    if (message_arena != submessage_arena) {
      back = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, back, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.back_ = back;
  // @@protoc_insertion_point(field_set_allocated:game.battlemon.items.LemonModel.back)
}

// repeated .game.battlemon.items.WeaponBundle attached_bundles = 11;
inline int LemonModel::_internal_attached_bundles_size() const {
  return _impl_.attached_bundles_.size();
}
inline int LemonModel::attached_bundles_size() const {
  return _internal_attached_bundles_size();
}
inline void LemonModel::clear_attached_bundles() {
  _impl_.attached_bundles_.Clear();
}
inline ::game::battlemon::items::WeaponBundle* LemonModel::mutable_attached_bundles(int index) {
  // @@protoc_insertion_point(field_mutable:game.battlemon.items.LemonModel.attached_bundles)
  return _impl_.attached_bundles_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::game::battlemon::items::WeaponBundle >*
LemonModel::mutable_attached_bundles() {
  // @@protoc_insertion_point(field_mutable_list:game.battlemon.items.LemonModel.attached_bundles)
  return &_impl_.attached_bundles_;
}
inline const ::game::battlemon::items::WeaponBundle& LemonModel::_internal_attached_bundles(int index) const {
  return _impl_.attached_bundles_.Get(index);
}
inline const ::game::battlemon::items::WeaponBundle& LemonModel::attached_bundles(int index) const {
  // @@protoc_insertion_point(field_get:game.battlemon.items.LemonModel.attached_bundles)
  return _internal_attached_bundles(index);
}
inline ::game::battlemon::items::WeaponBundle* LemonModel::_internal_add_attached_bundles() {
  return _impl_.attached_bundles_.Add();
}
inline ::game::battlemon::items::WeaponBundle* LemonModel::add_attached_bundles() {
  ::game::battlemon::items::WeaponBundle* _add = _internal_add_attached_bundles();
  // @@protoc_insertion_point(field_add:game.battlemon.items.LemonModel.attached_bundles)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::game::battlemon::items::WeaponBundle >&
LemonModel::attached_bundles() const {
  // @@protoc_insertion_point(field_list:game.battlemon.items.LemonModel.attached_bundles)
  return _impl_.attached_bundles_;
}

// -------------------------------------------------------------------

// OutfitModel

// string flavour = 1;
inline void OutfitModel::clear_flavour() {
  _impl_.flavour_.ClearToEmpty();
}
inline const std::string& OutfitModel::flavour() const {
  // @@protoc_insertion_point(field_get:game.battlemon.items.OutfitModel.flavour)
  return _internal_flavour();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OutfitModel::set_flavour(ArgT0&& arg0, ArgT... args) {
 
 _impl_.flavour_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:game.battlemon.items.OutfitModel.flavour)
}
inline std::string* OutfitModel::mutable_flavour() {
  std::string* _s = _internal_mutable_flavour();
  // @@protoc_insertion_point(field_mutable:game.battlemon.items.OutfitModel.flavour)
  return _s;
}
inline const std::string& OutfitModel::_internal_flavour() const {
  return _impl_.flavour_.Get();
}
inline void OutfitModel::_internal_set_flavour(const std::string& value) {
  
  _impl_.flavour_.Set(value, GetArenaForAllocation());
}
inline std::string* OutfitModel::_internal_mutable_flavour() {
  
  return _impl_.flavour_.Mutable(GetArenaForAllocation());
}
inline std::string* OutfitModel::release_flavour() {
  // @@protoc_insertion_point(field_release:game.battlemon.items.OutfitModel.flavour)
  return _impl_.flavour_.Release();
}
inline void OutfitModel::set_allocated_flavour(std::string* flavour) {
  if (flavour != nullptr) {
    
  } else {
    
  }
  _impl_.flavour_.SetAllocated(flavour, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.flavour_.IsDefault()) {
    _impl_.flavour_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:game.battlemon.items.OutfitModel.flavour)
}

// string token_id = 2;
inline void OutfitModel::clear_token_id() {
  _impl_.token_id_.ClearToEmpty();
}
inline const std::string& OutfitModel::token_id() const {
  // @@protoc_insertion_point(field_get:game.battlemon.items.OutfitModel.token_id)
  return _internal_token_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OutfitModel::set_token_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.token_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:game.battlemon.items.OutfitModel.token_id)
}
inline std::string* OutfitModel::mutable_token_id() {
  std::string* _s = _internal_mutable_token_id();
  // @@protoc_insertion_point(field_mutable:game.battlemon.items.OutfitModel.token_id)
  return _s;
}
inline const std::string& OutfitModel::_internal_token_id() const {
  return _impl_.token_id_.Get();
}
inline void OutfitModel::_internal_set_token_id(const std::string& value) {
  
  _impl_.token_id_.Set(value, GetArenaForAllocation());
}
inline std::string* OutfitModel::_internal_mutable_token_id() {
  
  return _impl_.token_id_.Mutable(GetArenaForAllocation());
}
inline std::string* OutfitModel::release_token_id() {
  // @@protoc_insertion_point(field_release:game.battlemon.items.OutfitModel.token_id)
  return _impl_.token_id_.Release();
}
inline void OutfitModel::set_allocated_token_id(std::string* token_id) {
  if (token_id != nullptr) {
    
  } else {
    
  }
  _impl_.token_id_.SetAllocated(token_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.token_id_.IsDefault()) {
    _impl_.token_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:game.battlemon.items.OutfitModel.token_id)
}

// .game.battlemon.items.OutfitKind kind = 3;
inline void OutfitModel::clear_kind() {
  _impl_.kind_ = 0;
}
inline ::game::battlemon::items::OutfitKind OutfitModel::_internal_kind() const {
  return static_cast< ::game::battlemon::items::OutfitKind >(_impl_.kind_);
}
inline ::game::battlemon::items::OutfitKind OutfitModel::kind() const {
  // @@protoc_insertion_point(field_get:game.battlemon.items.OutfitModel.kind)
  return _internal_kind();
}
inline void OutfitModel::_internal_set_kind(::game::battlemon::items::OutfitKind value) {
  
  _impl_.kind_ = value;
}
inline void OutfitModel::set_kind(::game::battlemon::items::OutfitKind value) {
  _internal_set_kind(value);
  // @@protoc_insertion_point(field_set:game.battlemon.items.OutfitModel.kind)
}

// -------------------------------------------------------------------

// WeaponBundle

// int32 bundle_num = 1;
inline void WeaponBundle::clear_bundle_num() {
  _impl_.bundle_num_ = 0;
}
inline int32_t WeaponBundle::_internal_bundle_num() const {
  return _impl_.bundle_num_;
}
inline int32_t WeaponBundle::bundle_num() const {
  // @@protoc_insertion_point(field_get:game.battlemon.items.WeaponBundle.bundle_num)
  return _internal_bundle_num();
}
inline void WeaponBundle::_internal_set_bundle_num(int32_t value) {
  
  _impl_.bundle_num_ = value;
}
inline void WeaponBundle::set_bundle_num(int32_t value) {
  _internal_set_bundle_num(value);
  // @@protoc_insertion_point(field_set:game.battlemon.items.WeaponBundle.bundle_num)
}

// repeated .game.battlemon.items.WeaponBundleItem items = 2;
inline int WeaponBundle::_internal_items_size() const {
  return _impl_.items_.size();
}
inline int WeaponBundle::items_size() const {
  return _internal_items_size();
}
inline void WeaponBundle::clear_items() {
  _impl_.items_.Clear();
}
inline ::game::battlemon::items::WeaponBundleItem* WeaponBundle::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:game.battlemon.items.WeaponBundle.items)
  return _impl_.items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::game::battlemon::items::WeaponBundleItem >*
WeaponBundle::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:game.battlemon.items.WeaponBundle.items)
  return &_impl_.items_;
}
inline const ::game::battlemon::items::WeaponBundleItem& WeaponBundle::_internal_items(int index) const {
  return _impl_.items_.Get(index);
}
inline const ::game::battlemon::items::WeaponBundleItem& WeaponBundle::items(int index) const {
  // @@protoc_insertion_point(field_get:game.battlemon.items.WeaponBundle.items)
  return _internal_items(index);
}
inline ::game::battlemon::items::WeaponBundleItem* WeaponBundle::_internal_add_items() {
  return _impl_.items_.Add();
}
inline ::game::battlemon::items::WeaponBundleItem* WeaponBundle::add_items() {
  ::game::battlemon::items::WeaponBundleItem* _add = _internal_add_items();
  // @@protoc_insertion_point(field_add:game.battlemon.items.WeaponBundle.items)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::game::battlemon::items::WeaponBundleItem >&
WeaponBundle::items() const {
  // @@protoc_insertion_point(field_list:game.battlemon.items.WeaponBundle.items)
  return _impl_.items_;
}

// string title = 3;
inline void WeaponBundle::clear_title() {
  _impl_.title_.ClearToEmpty();
}
inline const std::string& WeaponBundle::title() const {
  // @@protoc_insertion_point(field_get:game.battlemon.items.WeaponBundle.title)
  return _internal_title();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WeaponBundle::set_title(ArgT0&& arg0, ArgT... args) {
 
 _impl_.title_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:game.battlemon.items.WeaponBundle.title)
}
inline std::string* WeaponBundle::mutable_title() {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:game.battlemon.items.WeaponBundle.title)
  return _s;
}
inline const std::string& WeaponBundle::_internal_title() const {
  return _impl_.title_.Get();
}
inline void WeaponBundle::_internal_set_title(const std::string& value) {
  
  _impl_.title_.Set(value, GetArenaForAllocation());
}
inline std::string* WeaponBundle::_internal_mutable_title() {
  
  return _impl_.title_.Mutable(GetArenaForAllocation());
}
inline std::string* WeaponBundle::release_title() {
  // @@protoc_insertion_point(field_release:game.battlemon.items.WeaponBundle.title)
  return _impl_.title_.Release();
}
inline void WeaponBundle::set_allocated_title(std::string* title) {
  if (title != nullptr) {
    
  } else {
    
  }
  _impl_.title_.SetAllocated(title, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.title_.IsDefault()) {
    _impl_.title_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:game.battlemon.items.WeaponBundle.title)
}

// int32 level = 4;
inline void WeaponBundle::clear_level() {
  _impl_.level_ = 0;
}
inline int32_t WeaponBundle::_internal_level() const {
  return _impl_.level_;
}
inline int32_t WeaponBundle::level() const {
  // @@protoc_insertion_point(field_get:game.battlemon.items.WeaponBundle.level)
  return _internal_level();
}
inline void WeaponBundle::_internal_set_level(int32_t value) {
  
  _impl_.level_ = value;
}
inline void WeaponBundle::set_level(int32_t value) {
  _internal_set_level(value);
  // @@protoc_insertion_point(field_set:game.battlemon.items.WeaponBundle.level)
}

// -------------------------------------------------------------------

// WeaponBundleItem

// .game.battlemon.items.WeaponBundleItemType item_type = 1;
inline void WeaponBundleItem::clear_item_type() {
  _impl_.item_type_ = 0;
}
inline ::game::battlemon::items::WeaponBundleItemType WeaponBundleItem::_internal_item_type() const {
  return static_cast< ::game::battlemon::items::WeaponBundleItemType >(_impl_.item_type_);
}
inline ::game::battlemon::items::WeaponBundleItemType WeaponBundleItem::item_type() const {
  // @@protoc_insertion_point(field_get:game.battlemon.items.WeaponBundleItem.item_type)
  return _internal_item_type();
}
inline void WeaponBundleItem::_internal_set_item_type(::game::battlemon::items::WeaponBundleItemType value) {
  
  _impl_.item_type_ = value;
}
inline void WeaponBundleItem::set_item_type(::game::battlemon::items::WeaponBundleItemType value) {
  _internal_set_item_type(value);
  // @@protoc_insertion_point(field_set:game.battlemon.items.WeaponBundleItem.item_type)
}

// string skin = 2;
inline void WeaponBundleItem::clear_skin() {
  _impl_.skin_.ClearToEmpty();
}
inline const std::string& WeaponBundleItem::skin() const {
  // @@protoc_insertion_point(field_get:game.battlemon.items.WeaponBundleItem.skin)
  return _internal_skin();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WeaponBundleItem::set_skin(ArgT0&& arg0, ArgT... args) {
 
 _impl_.skin_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:game.battlemon.items.WeaponBundleItem.skin)
}
inline std::string* WeaponBundleItem::mutable_skin() {
  std::string* _s = _internal_mutable_skin();
  // @@protoc_insertion_point(field_mutable:game.battlemon.items.WeaponBundleItem.skin)
  return _s;
}
inline const std::string& WeaponBundleItem::_internal_skin() const {
  return _impl_.skin_.Get();
}
inline void WeaponBundleItem::_internal_set_skin(const std::string& value) {
  
  _impl_.skin_.Set(value, GetArenaForAllocation());
}
inline std::string* WeaponBundleItem::_internal_mutable_skin() {
  
  return _impl_.skin_.Mutable(GetArenaForAllocation());
}
inline std::string* WeaponBundleItem::release_skin() {
  // @@protoc_insertion_point(field_release:game.battlemon.items.WeaponBundleItem.skin)
  return _impl_.skin_.Release();
}
inline void WeaponBundleItem::set_allocated_skin(std::string* skin) {
  if (skin != nullptr) {
    
  } else {
    
  }
  _impl_.skin_.SetAllocated(skin, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.skin_.IsDefault()) {
    _impl_.skin_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:game.battlemon.items.WeaponBundleItem.skin)
}

// .game.battlemon.items.WeaponBundleSlotType slot_type = 3;
inline void WeaponBundleItem::clear_slot_type() {
  _impl_.slot_type_ = 0;
}
inline ::game::battlemon::items::WeaponBundleSlotType WeaponBundleItem::_internal_slot_type() const {
  return static_cast< ::game::battlemon::items::WeaponBundleSlotType >(_impl_.slot_type_);
}
inline ::game::battlemon::items::WeaponBundleSlotType WeaponBundleItem::slot_type() const {
  // @@protoc_insertion_point(field_get:game.battlemon.items.WeaponBundleItem.slot_type)
  return _internal_slot_type();
}
inline void WeaponBundleItem::_internal_set_slot_type(::game::battlemon::items::WeaponBundleSlotType value) {
  
  _impl_.slot_type_ = value;
}
inline void WeaponBundleItem::set_slot_type(::game::battlemon::items::WeaponBundleSlotType value) {
  _internal_set_slot_type(value);
  // @@protoc_insertion_point(field_set:game.battlemon.items.WeaponBundleItem.slot_type)
}

// -------------------------------------------------------------------

// GetBundlesRequest

// -------------------------------------------------------------------

// GetBundlesResponse

// repeated .game.battlemon.items.WeaponBundle bundles = 1;
inline int GetBundlesResponse::_internal_bundles_size() const {
  return _impl_.bundles_.size();
}
inline int GetBundlesResponse::bundles_size() const {
  return _internal_bundles_size();
}
inline void GetBundlesResponse::clear_bundles() {
  _impl_.bundles_.Clear();
}
inline ::game::battlemon::items::WeaponBundle* GetBundlesResponse::mutable_bundles(int index) {
  // @@protoc_insertion_point(field_mutable:game.battlemon.items.GetBundlesResponse.bundles)
  return _impl_.bundles_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::game::battlemon::items::WeaponBundle >*
GetBundlesResponse::mutable_bundles() {
  // @@protoc_insertion_point(field_mutable_list:game.battlemon.items.GetBundlesResponse.bundles)
  return &_impl_.bundles_;
}
inline const ::game::battlemon::items::WeaponBundle& GetBundlesResponse::_internal_bundles(int index) const {
  return _impl_.bundles_.Get(index);
}
inline const ::game::battlemon::items::WeaponBundle& GetBundlesResponse::bundles(int index) const {
  // @@protoc_insertion_point(field_get:game.battlemon.items.GetBundlesResponse.bundles)
  return _internal_bundles(index);
}
inline ::game::battlemon::items::WeaponBundle* GetBundlesResponse::_internal_add_bundles() {
  return _impl_.bundles_.Add();
}
inline ::game::battlemon::items::WeaponBundle* GetBundlesResponse::add_bundles() {
  ::game::battlemon::items::WeaponBundle* _add = _internal_add_bundles();
  // @@protoc_insertion_point(field_add:game.battlemon.items.GetBundlesResponse.bundles)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::game::battlemon::items::WeaponBundle >&
GetBundlesResponse::bundles() const {
  // @@protoc_insertion_point(field_list:game.battlemon.items.GetBundlesResponse.bundles)
  return _impl_.bundles_;
}

// -------------------------------------------------------------------

// EditBundleRequest

// int32 bundle_num = 1;
inline void EditBundleRequest::clear_bundle_num() {
  _impl_.bundle_num_ = 0;
}
inline int32_t EditBundleRequest::_internal_bundle_num() const {
  return _impl_.bundle_num_;
}
inline int32_t EditBundleRequest::bundle_num() const {
  // @@protoc_insertion_point(field_get:game.battlemon.items.EditBundleRequest.bundle_num)
  return _internal_bundle_num();
}
inline void EditBundleRequest::_internal_set_bundle_num(int32_t value) {
  
  _impl_.bundle_num_ = value;
}
inline void EditBundleRequest::set_bundle_num(int32_t value) {
  _internal_set_bundle_num(value);
  // @@protoc_insertion_point(field_set:game.battlemon.items.EditBundleRequest.bundle_num)
}

// repeated .game.battlemon.items.WeaponBundleItem items = 2;
inline int EditBundleRequest::_internal_items_size() const {
  return _impl_.items_.size();
}
inline int EditBundleRequest::items_size() const {
  return _internal_items_size();
}
inline void EditBundleRequest::clear_items() {
  _impl_.items_.Clear();
}
inline ::game::battlemon::items::WeaponBundleItem* EditBundleRequest::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:game.battlemon.items.EditBundleRequest.items)
  return _impl_.items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::game::battlemon::items::WeaponBundleItem >*
EditBundleRequest::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:game.battlemon.items.EditBundleRequest.items)
  return &_impl_.items_;
}
inline const ::game::battlemon::items::WeaponBundleItem& EditBundleRequest::_internal_items(int index) const {
  return _impl_.items_.Get(index);
}
inline const ::game::battlemon::items::WeaponBundleItem& EditBundleRequest::items(int index) const {
  // @@protoc_insertion_point(field_get:game.battlemon.items.EditBundleRequest.items)
  return _internal_items(index);
}
inline ::game::battlemon::items::WeaponBundleItem* EditBundleRequest::_internal_add_items() {
  return _impl_.items_.Add();
}
inline ::game::battlemon::items::WeaponBundleItem* EditBundleRequest::add_items() {
  ::game::battlemon::items::WeaponBundleItem* _add = _internal_add_items();
  // @@protoc_insertion_point(field_add:game.battlemon.items.EditBundleRequest.items)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::game::battlemon::items::WeaponBundleItem >&
EditBundleRequest::items() const {
  // @@protoc_insertion_point(field_list:game.battlemon.items.EditBundleRequest.items)
  return _impl_.items_;
}

// string title = 3;
inline void EditBundleRequest::clear_title() {
  _impl_.title_.ClearToEmpty();
}
inline const std::string& EditBundleRequest::title() const {
  // @@protoc_insertion_point(field_get:game.battlemon.items.EditBundleRequest.title)
  return _internal_title();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EditBundleRequest::set_title(ArgT0&& arg0, ArgT... args) {
 
 _impl_.title_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:game.battlemon.items.EditBundleRequest.title)
}
inline std::string* EditBundleRequest::mutable_title() {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:game.battlemon.items.EditBundleRequest.title)
  return _s;
}
inline const std::string& EditBundleRequest::_internal_title() const {
  return _impl_.title_.Get();
}
inline void EditBundleRequest::_internal_set_title(const std::string& value) {
  
  _impl_.title_.Set(value, GetArenaForAllocation());
}
inline std::string* EditBundleRequest::_internal_mutable_title() {
  
  return _impl_.title_.Mutable(GetArenaForAllocation());
}
inline std::string* EditBundleRequest::release_title() {
  // @@protoc_insertion_point(field_release:game.battlemon.items.EditBundleRequest.title)
  return _impl_.title_.Release();
}
inline void EditBundleRequest::set_allocated_title(std::string* title) {
  if (title != nullptr) {
    
  } else {
    
  }
  _impl_.title_.SetAllocated(title, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.title_.IsDefault()) {
    _impl_.title_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:game.battlemon.items.EditBundleRequest.title)
}

// -------------------------------------------------------------------

// AttachBundleRequest

// int32 bundle_num = 1;
inline void AttachBundleRequest::clear_bundle_num() {
  _impl_.bundle_num_ = 0;
}
inline int32_t AttachBundleRequest::_internal_bundle_num() const {
  return _impl_.bundle_num_;
}
inline int32_t AttachBundleRequest::bundle_num() const {
  // @@protoc_insertion_point(field_get:game.battlemon.items.AttachBundleRequest.bundle_num)
  return _internal_bundle_num();
}
inline void AttachBundleRequest::_internal_set_bundle_num(int32_t value) {
  
  _impl_.bundle_num_ = value;
}
inline void AttachBundleRequest::set_bundle_num(int32_t value) {
  _internal_set_bundle_num(value);
  // @@protoc_insertion_point(field_set:game.battlemon.items.AttachBundleRequest.bundle_num)
}

// string lemon_id = 2;
inline void AttachBundleRequest::clear_lemon_id() {
  _impl_.lemon_id_.ClearToEmpty();
}
inline const std::string& AttachBundleRequest::lemon_id() const {
  // @@protoc_insertion_point(field_get:game.battlemon.items.AttachBundleRequest.lemon_id)
  return _internal_lemon_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AttachBundleRequest::set_lemon_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.lemon_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:game.battlemon.items.AttachBundleRequest.lemon_id)
}
inline std::string* AttachBundleRequest::mutable_lemon_id() {
  std::string* _s = _internal_mutable_lemon_id();
  // @@protoc_insertion_point(field_mutable:game.battlemon.items.AttachBundleRequest.lemon_id)
  return _s;
}
inline const std::string& AttachBundleRequest::_internal_lemon_id() const {
  return _impl_.lemon_id_.Get();
}
inline void AttachBundleRequest::_internal_set_lemon_id(const std::string& value) {
  
  _impl_.lemon_id_.Set(value, GetArenaForAllocation());
}
inline std::string* AttachBundleRequest::_internal_mutable_lemon_id() {
  
  return _impl_.lemon_id_.Mutable(GetArenaForAllocation());
}
inline std::string* AttachBundleRequest::release_lemon_id() {
  // @@protoc_insertion_point(field_release:game.battlemon.items.AttachBundleRequest.lemon_id)
  return _impl_.lemon_id_.Release();
}
inline void AttachBundleRequest::set_allocated_lemon_id(std::string* lemon_id) {
  if (lemon_id != nullptr) {
    
  } else {
    
  }
  _impl_.lemon_id_.SetAllocated(lemon_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.lemon_id_.IsDefault()) {
    _impl_.lemon_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:game.battlemon.items.AttachBundleRequest.lemon_id)
}

// -------------------------------------------------------------------

// DetachBundleRequest

// int32 bundle_num = 1;
inline void DetachBundleRequest::clear_bundle_num() {
  _impl_.bundle_num_ = 0;
}
inline int32_t DetachBundleRequest::_internal_bundle_num() const {
  return _impl_.bundle_num_;
}
inline int32_t DetachBundleRequest::bundle_num() const {
  // @@protoc_insertion_point(field_get:game.battlemon.items.DetachBundleRequest.bundle_num)
  return _internal_bundle_num();
}
inline void DetachBundleRequest::_internal_set_bundle_num(int32_t value) {
  
  _impl_.bundle_num_ = value;
}
inline void DetachBundleRequest::set_bundle_num(int32_t value) {
  _internal_set_bundle_num(value);
  // @@protoc_insertion_point(field_set:game.battlemon.items.DetachBundleRequest.bundle_num)
}

// string lemon_id = 2;
inline void DetachBundleRequest::clear_lemon_id() {
  _impl_.lemon_id_.ClearToEmpty();
}
inline const std::string& DetachBundleRequest::lemon_id() const {
  // @@protoc_insertion_point(field_get:game.battlemon.items.DetachBundleRequest.lemon_id)
  return _internal_lemon_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DetachBundleRequest::set_lemon_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.lemon_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:game.battlemon.items.DetachBundleRequest.lemon_id)
}
inline std::string* DetachBundleRequest::mutable_lemon_id() {
  std::string* _s = _internal_mutable_lemon_id();
  // @@protoc_insertion_point(field_mutable:game.battlemon.items.DetachBundleRequest.lemon_id)
  return _s;
}
inline const std::string& DetachBundleRequest::_internal_lemon_id() const {
  return _impl_.lemon_id_.Get();
}
inline void DetachBundleRequest::_internal_set_lemon_id(const std::string& value) {
  
  _impl_.lemon_id_.Set(value, GetArenaForAllocation());
}
inline std::string* DetachBundleRequest::_internal_mutable_lemon_id() {
  
  return _impl_.lemon_id_.Mutable(GetArenaForAllocation());
}
inline std::string* DetachBundleRequest::release_lemon_id() {
  // @@protoc_insertion_point(field_release:game.battlemon.items.DetachBundleRequest.lemon_id)
  return _impl_.lemon_id_.Release();
}
inline void DetachBundleRequest::set_allocated_lemon_id(std::string* lemon_id) {
  if (lemon_id != nullptr) {
    
  } else {
    
  }
  _impl_.lemon_id_.SetAllocated(lemon_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.lemon_id_.IsDefault()) {
    _impl_.lemon_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:game.battlemon.items.DetachBundleRequest.lemon_id)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace items
}  // namespace battlemon
}  // namespace game

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::game::battlemon::items::OutfitKind> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::game::battlemon::items::OutfitKind>() {
  return ::game::battlemon::items::OutfitKind_descriptor();
}
template <> struct is_proto_enum< ::game::battlemon::items::WeaponBundleItemType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::game::battlemon::items::WeaponBundleItemType>() {
  return ::game::battlemon::items::WeaponBundleItemType_descriptor();
}
template <> struct is_proto_enum< ::game::battlemon::items::WeaponBundleSlotType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::game::battlemon::items::WeaponBundleSlotType>() {
  return ::game::battlemon::items::WeaponBundleSlotType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_items_2eproto
